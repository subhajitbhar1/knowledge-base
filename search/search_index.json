{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Knowledge Base","text":"<p>A curated collection of Python programming concepts explained clearly. Each topic is answered with practical examples, common gotchas, and best practices.</p>"},{"location":"#browse-by-topic","title":"Browse by Topic","text":"<ul> <li>Python Lists - 34 in-depth articles</li> <li>Python Tuples - 33 in-depth articles</li> <li>Python Async &amp; Asyncio - 29 in-depth articles</li> <li>Python Dictionaries - Coming soon</li> <li>Python Sets - Coming soon</li> </ul>"},{"location":"#whats-inside","title":"What's Inside?","text":"<p>Each topic contains:</p> <ul> <li>Clear explanations - Complex concepts explained simply</li> <li>Practical examples - Runnable Python code with outputs</li> <li>Common gotchas - Learn from typical mistakes</li> <li>Best practices - When to use (and when not to use)</li> <li>Performance tips - Trade-offs and optimization insights</li> </ul>"},{"location":"#quick-search","title":"Quick Search","text":"<p>Use the search bar above to find specific topics across all articles.</p> <p>More topics coming soon. This knowledge base is continuously growing.</p>"},{"location":"python-async/","title":"Python Async &amp; Asyncio","text":"<p>Everything you need to know about asynchronous programming in Python - from basics to advanced patterns. 29 in-depth articles covering async/await syntax, asyncio library, performance comparisons, and practical use cases.</p>"},{"location":"python-async/#basics-fundamentals","title":"Basics &amp; Fundamentals","text":"<p>Start Here</p> <p>New to async Python? These articles cover the foundational concepts.</p> <ul> <li>What is async in Python?</li> <li>What is asyncio in Python?</li> <li>What does async do in Python?</li> <li>Is asyncio part of Python?</li> <li>Is Python asynchronous?</li> <li>Is Python synchronous or asynchronous?</li> </ul>"},{"location":"python-async/#functions-syntax","title":"Functions &amp; Syntax","text":"<p>Defining Async Functions</p> <p>Learn how to create and work with async functions in Python.</p> <ul> <li>What is async function in Python?</li> <li>What is async def in Python?</li> <li>What is async and await in Python?</li> <li>How to create async functions in Python?</li> <li>How to call an async function in Python?</li> <li>Can init be async in Python?</li> </ul>"},{"location":"python-async/#working-with-asyncio","title":"Working with Asyncio","text":"<p>Practical Usage</p> <p>Apply async/await patterns in real-world scenarios.</p> <ul> <li>How to use asyncio in Python?</li> <li>How async works in Python?</li> <li>How to use async await in Python?</li> <li>How to cancel async tasks in Python?</li> <li>How to await multiple async tasks in Python?</li> </ul>"},{"location":"python-async/#advanced-topics","title":"Advanced Topics","text":"<p>Deep Dive</p> <p>Advanced patterns for experienced async developers.</p> <ul> <li>How to use async generator in Python?</li> <li>What is a decorator in Python (in async context)?</li> <li>How to debug async Python code?</li> <li>Is foreach async in Python?</li> </ul>"},{"location":"python-async/#performance-comparison","title":"Performance &amp; Comparison","text":"<p>Threading vs Asyncio</p> <p>Understand performance trade-offs and choose the right concurrency model.</p> <ul> <li>Is Python single threaded?</li> <li>Can Python be multithreaded?</li> <li>Is asyncio faster than threading?</li> <li>Which is better threading or asyncio in Python?</li> <li>Is JavaScript async like Python?</li> </ul>"},{"location":"python-async/#why-use-async","title":"Why Use Async?","text":"<p>Use Cases &amp; Benefits</p> <p>Learn when and why to use asynchronous programming.</p> <ul> <li>Why use async in Python?</li> <li>Why use async await in Python?</li> <li>Why use asyncio in Python?</li> </ul> <p>:octicons-arrow-left-24: Back to Topics</p>"},{"location":"python-async/can-init-be-async-in-python/","title":"Can init be async in Python?","text":"<p>In short</p> <p>No, <code>__init__</code> cannot be async. Python's object instantiation expects <code>__init__</code> to return <code>None</code> immediately, not a coroutine. Making <code>__init__</code> async would break the fundamental <code>obj = MyClass()</code> syntax. Instead, use a factory pattern: define an async class method that creates the instance, then calls an async setup method. Or use <code>__await__</code> with <code>__new__</code> for advanced cases. The common pattern is <code>obj = await MyClass.create()</code>. It's a design limitation, not a bug\u2014synchronous initialization keeps Python's object model simple.</p> <p>Here's the right way to handle async initialization:</p> <pre><code>import asyncio\n\nclass Database:\n    def __init__(self):\n        self.connection = None\n\n    async def connect(self):\n        \"\"\"Async setup after __init__\"\"\"\n        print(\"Connecting...\")\n        await asyncio.sleep(1)  # Simulates async I/O\n        self.connection = \"connected\"\n        return self\n\n    @classmethod\n    async def create(cls):\n        \"\"\"Factory method for async creation\"\"\"\n        self = cls()\n        await self.connect()\n        return self\n\n# Usage\nasync def main():\n    db = await Database.create()\n    print(f\"DB status: {db.connection}\")\n\nasyncio.run(main())\n</code></pre> <p>The <code>create()</code> class method constructs the object, then awaits the async setup. This pattern is clean and widely used in async codebases.</p> <p>Here's what often trips people up: trying <code>async def __init__</code> gives a <code>TypeError: __init__() should return None, not 'coroutine'</code>. Python enforces synchronous construction to keep the language consistent.</p>"},{"location":"python-async/can-init-be-async-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>You can't await MyClass() \u2014 constructors are synchronous. Use a factory method or context manager instead.</li> <li><code>__await__</code> exists but is tricky \u2014 you can define <code>__await__</code> to make an object awaitable, but it's advanced and rarely needed. Stick with factory methods.</li> <li>Context managers work great \u2014 use <code>async with await MyClass.create():</code> for resources that need async setup and cleanup.</li> </ul>"},{"location":"python-async/can-init-be-async-in-python/#see-also","title":"See also","text":"<ul> <li>How to create async functions in Python?</li> <li>What is async function in Python?</li> <li>External: https://docs.python.org/3/reference/datamodel.html#object.await</li> </ul>"},{"location":"python-async/can-python-be-multithreaded/","title":"Can Python be multithreaded?","text":"<p>In short</p> <p>Yes, Python can be multithreaded using the <code>threading</code> module. You can create and run multiple threads easily. However, the Global Interpreter Lock (GIL) means only one thread executes Python bytecode at a time, so threads won't give you true parallelism for CPU-intensive work. Threads shine for I/O-bound tasks\u2014downloading files, making API calls, reading from disk\u2014because the GIL releases during I/O waits, letting other threads work. If you need real parallel computation, use <code>multiprocessing</code> instead.</p> <p>Here's a practical example of multithreading for I/O:</p> <pre><code>import threading\nimport time\n\ndef download_file(file_id):\n    print(f\"Downloading {file_id}...\")\n    time.sleep(2)  # Simulates I/O wait\n    print(f\"Downloaded {file_id}\")\n\n# Sequential approach\nstart = time.time()\nfor i in range(3):\n    download_file(i)\nprint(f\"Sequential: {time.time() - start:.2f}s\")  # ~6 seconds\n\n# Threaded approach\nstart = time.time()\nthreads = []\nfor i in range(3):\n    t = threading.Thread(target=download_file, args=(i,))\n    t.start()\n    threads.append(t)\n\nfor t in threads:\n    t.join()\nprint(f\"Threaded: {time.time() - start:.2f}s\")  # ~2 seconds\n</code></pre> <p>The threaded version is 3x faster because all downloads wait simultaneously. The GIL doesn't matter here\u2014threads are just waiting for I/O, not computing.</p> <p>Here's the catch: if your threads do heavy computation, the GIL forces them to take turns, and you gain nothing. Threading is for waiting, not calculating.</p>"},{"location":"python-async/can-python-be-multithreaded/#gotchas","title":"Gotchas","text":"<ul> <li>Threading \u2260 parallelism \u2014 due to the GIL, threads don't run simultaneously for CPU work. They're concurrent (interleaved), not parallel.</li> <li>Race conditions still exist \u2014 even with the GIL, you can have bugs when threads modify shared data. Use <code>threading.Lock()</code> to protect shared resources.</li> <li>Thread overhead adds up \u2014 creating thousands of threads is expensive. For high concurrency, consider <code>asyncio</code> or a thread pool (<code>concurrent.futures.ThreadPoolExecutor</code>).</li> </ul>"},{"location":"python-async/can-python-be-multithreaded/#see-also","title":"See also","text":"<ul> <li>Is Python single threaded?</li> <li>Which is better threading or asyncio in Python?</li> <li>External: https://docs.python.org/3/library/threading.html</li> </ul>"},{"location":"python-async/how-async-works-in-python/","title":"How async works in Python?","text":"<p>In short</p> <p>Async works through an event loop that manages coroutines. When you <code>await</code> something, your coroutine pauses and returns control to the event loop, which then runs other coroutines that are ready. Think of it like a juggler: the event loop keeps multiple balls (coroutines) in the air, giving each one attention when it's ready to move forward. When a coroutine hits <code>await</code> on I/O, it says \"I'm waiting, run someone else,\" and the loop switches to another task. This cooperative multitasking means tasks voluntarily yield\u2014no preemption, no threads.</p> <p>Here's a visualization of how the event loop switches between tasks:</p> <pre><code>import asyncio\nimport time\n\nasync def task(name, delay):\n    print(f\"[{time.time():.2f}] {name}: Started\")\n    await asyncio.sleep(delay)\n    print(f\"[{time.time():.2f}] {name}: Done\")\n\nasync def main():\n    await asyncio.gather(\n        task(\"Task-A\", 2),\n        task(\"Task-B\", 1),\n        task(\"Task-C\", 1.5)\n    )\n\nasyncio.run(main())\n</code></pre> <p>Output: <pre><code>[12.34] Task-A: Started\n[12.34] Task-B: Started\n[12.34] Task-C: Started\n[13.34] Task-B: Done\n[13.84] Task-C: Done\n[14.34] Task-A: Done\n</code></pre></p> <p>All tasks start immediately (they're queued), but the event loop interleaves them. Each <code>await</code> is a yield point where the loop can switch to another task. The loop keeps cycling through ready tasks until all are done.</p> <p>Here's the insight that clicks for most people: async isn't magic parallelism. It's organized waiting. The event loop doesn't make things faster\u2014it just prevents idle time from blocking everything else.</p>"},{"location":"python-async/how-async-works-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Blocking calls freeze everything \u2014 if you use <code>time.sleep()</code> or <code>requests.get()</code> in async code, the entire event loop stops. Always use async equivalents.</li> <li>Await is required \u2014 forgetting <code>await</code> on an async function call returns a coroutine object, not the result. Python warns you, but it's a common mistake.</li> <li>Only one loop runs at a time \u2014 you can't nest event loops easily. Use <code>asyncio.run()</code> once at the top level, not inside async functions.</li> </ul>"},{"location":"python-async/how-async-works-in-python/#see-also","title":"See also","text":"<ul> <li>What is async and await in Python?</li> <li>How to use asyncio in Python?</li> <li>External: https://realpython.com/async-io-python/</li> </ul>"},{"location":"python-async/how-to-await-multiple-async-tasks-in-python/","title":"How to await multiple async tasks in Python?","text":"<p>In short</p> <p>Use <code>asyncio.gather()</code> to run multiple tasks concurrently and get all results at once. Use <code>asyncio.as_completed()</code> to process results as each task finishes. Use <code>asyncio.create_task()</code> to start tasks early and await them later. All three let you run tasks concurrently\u2014the difference is how you collect results. <code>gather()</code> waits for everything and preserves order. <code>as_completed()</code> gives you results in completion order. <code>create_task()</code> gives you fine-grained control over when tasks start and finish. Choose based on whether you need ordered results, immediate processing, or custom orchestration.</p> <p>Here are all the patterns for running multiple tasks:</p> <pre><code>import asyncio\nimport time\n\nasync def fetch_data(source, delay):\n    await asyncio.sleep(delay)\n    return f\"Data from {source}\"\n\n# Method 1: asyncio.gather() - wait for all, ordered results\nasync def gather_example():\n    start = time.time()\n    results = await asyncio.gather(\n        fetch_data(\"API\", 2),\n        fetch_data(\"DB\", 1),\n        fetch_data(\"Cache\", 0.5)\n    )\n    print(f\"Gather ({time.time()-start:.1f}s): {results}\")\n    # Output: ['Data from API', 'Data from DB', 'Data from Cache']\n\n# Method 2: asyncio.as_completed() - process as they finish\nasync def as_completed_example():\n    start = time.time()\n    tasks = [\n        fetch_data(\"API\", 2),\n        fetch_data(\"DB\", 1),\n        fetch_data(\"Cache\", 0.5)\n    ]\n\n    for coro in asyncio.as_completed(tasks):\n        result = await coro\n        elapsed = time.time() - start\n        print(f\"Completed ({elapsed:.1f}s): {result}\")\n    # Cache finishes first, then DB, then API\n\n# Method 3: create_task() - start early, await later\nasync def create_task_example():\n    start = time.time()\n    # Start all tasks immediately\n    task1 = asyncio.create_task(fetch_data(\"API\", 2))\n    task2 = asyncio.create_task(fetch_data(\"DB\", 1))\n    task3 = asyncio.create_task(fetch_data(\"Cache\", 0.5))\n\n    # Do other work while tasks run\n    await asyncio.sleep(0.3)\n    print(\"Did some work while tasks run...\")\n\n    # Collect results\n    result1 = await task1\n    result2 = await task2\n    result3 = await task3\n    print(f\"Results: {[result1, result2, result3]}\")\n\n# Run examples\nasyncio.run(gather_example())\nasyncio.run(as_completed_example())\nasyncio.run(create_task_example())\n</code></pre> <p>All three methods run tasks concurrently (total time ~2s, not 3.5s). The difference is result collection.</p> <p>Here's the decision guide: - Need all results in order? \u2192 <code>gather()</code> - Want to process results immediately? \u2192 <code>as_completed()</code> - Need fine control or want to start tasks early? \u2192 <code>create_task()</code></p>"},{"location":"python-async/how-to-await-multiple-async-tasks-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>gather() stops on first exception by default \u2014 use <code>return_exceptions=True</code> to collect all results even if some fail.</li> <li>Don't await in a loop without create_task() \u2014 <code>for x in items: await process(x)</code> runs sequentially. Use <code>gather([process(x) for x in items])</code> for concurrency.</li> <li>as_completed() yields coroutines, not results \u2014 you must await each one: <code>for coro in as_completed(tasks): result = await coro</code>.</li> </ul>"},{"location":"python-async/how-to-await-multiple-async-tasks-in-python/#see-also","title":"See also","text":"<ul> <li>How to use asyncio in Python?</li> <li>How to cancel async tasks in Python?</li> <li>External: https://docs.python.org/3/library/asyncio-task.html#running-tasks-concurrently</li> </ul>"},{"location":"python-async/how-to-call-an-async-function-in-python/","title":"How to call an async function in Python?","text":"<p>In short</p> <p>From sync code, use <code>asyncio.run(my_async_function())</code>. From async code, use <code>await my_async_function()</code>. That's it. You can't just call <code>my_async_function()</code> and get the result\u2014it returns a coroutine object that needs to be awaited or run. Think of async functions like tasks you schedule, not functions you execute directly. <code>asyncio.run()</code> sets up the event loop and runs the coroutine, while <code>await</code> schedules it in the current loop. Choose based on your context: starting from scratch? Use <code>asyncio.run()</code>. Already in an async function? Use <code>await</code>.</p> <p>Here are all the ways to call async functions:</p> <pre><code>import asyncio\n\nasync def greet(name):\n    await asyncio.sleep(0.1)\n    return f\"Hello, {name}!\"\n\n# Method 1: From sync code (entry point)\nresult = asyncio.run(greet(\"Alice\"))\nprint(result)  # \"Hello, Alice!\"\n\n# Method 2: Inside another async function\nasync def main():\n    result = await greet(\"Bob\")  # Use await\n    print(result)\n\nasyncio.run(main())\n\n# Method 3: Create task for concurrent execution\nasync def concurrent():\n    task1 = asyncio.create_task(greet(\"Charlie\"))\n    task2 = asyncio.create_task(greet(\"Diana\"))\n\n    # Wait for both\n    results = await asyncio.gather(task1, task2)\n    print(results)  # ['Hello, Charlie!', 'Hello, Diana!']\n\nasyncio.run(concurrent())\n</code></pre> <p>Wrong way: <pre><code>coro = greet(\"Eve\")  # Returns coroutine, doesn't run\nprint(coro)  # &lt;coroutine object greet at 0x...&gt;\n# Python warns: RuntimeWarning: coroutine 'greet' was never awaited\n</code></pre></p> <p>The coroutine object is like a recipe\u2014it describes what to do, but doesn't do it. You need <code>await</code> or <code>asyncio.run()</code> to actually execute it.</p> <p>Here's what catches people: calling an async function looks normal, but it doesn't run immediately. Always await or run it.</p>"},{"location":"python-async/how-to-call-an-async-function-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Don't call asyncio.run() in async code \u2014 you'll get \"RuntimeError: asyncio.run() cannot be called from a running event loop.\" Use <code>await</code> instead.</li> <li>Coroutines expire \u2014 if you create a coroutine and don't await it quickly, Python will warn you. Always await or run coroutines promptly.</li> <li>asyncio.create_task() needs a running loop \u2014 you can only call it inside an async function. For the entry point, use <code>asyncio.run()</code>.</li> </ul>"},{"location":"python-async/how-to-call-an-async-function-in-python/#see-also","title":"See also","text":"<ul> <li>How to use async await in Python?</li> <li>What is async function in Python?</li> <li>External: https://docs.python.org/3/library/asyncio-task.html</li> </ul>"},{"location":"python-async/how-to-cancel-async-tasks-in-python/","title":"How to cancel async tasks in Python?","text":"<p>In short</p> <p>Call <code>.cancel()</code> on a task object to request cancellation. The task will raise <code>asyncio.CancelledError</code> at its next <code>await</code> point, which you can catch to clean up resources. Cancellation is cooperative\u2014tasks don't stop immediately, they stop when they next yield control. Create tasks with <code>asyncio.create_task()</code> to get a task object you can cancel. Use try/except <code>CancelledError</code> to handle cleanup gracefully. Common use case: timeouts, user-initiated stops, or shutting down a server. The pattern: create tasks explicitly, save references, cancel when needed, and always handle CancelledError for cleanup.</p> <p>Here's how to cancel tasks properly:</p> <pre><code>import asyncio\n\nasync def long_running_task(name):\n    try:\n        print(f\"{name}: Starting\")\n        for i in range(10):\n            await asyncio.sleep(1)\n            print(f\"{name}: Step {i}\")\n    except asyncio.CancelledError:\n        print(f\"{name}: Cancelled! Cleaning up...\")\n        # Do cleanup here\n        raise  # Re-raise to let asyncio know we handled it\n\nasync def main():\n    # Create tasks (not just coroutines)\n    task1 = asyncio.create_task(long_running_task(\"Task1\"))\n    task2 = asyncio.create_task(long_running_task(\"Task2\"))\n\n    # Let them run for a bit\n    await asyncio.sleep(2.5)\n\n    # Cancel one task\n    task1.cancel()\n\n    # Wait for both (task1 will raise CancelledError)\n    results = await asyncio.gather(task1, task2, return_exceptions=True)\n\n    for i, result in enumerate(results, 1):\n        if isinstance(result, asyncio.CancelledError):\n            print(f\"Task{i} was cancelled\")\n        else:\n            print(f\"Task{i} result: {result}\")\n\nasyncio.run(main())\n</code></pre> <p>Output: <pre><code>Task1: Starting\nTask2: Starting\nTask1: Step 0\nTask2: Step 0\nTask1: Step 1\nTask2: Step 1\nTask1: Cancelled! Cleaning up...\nTask1 was cancelled\nTask2: Step 2\n...\n</code></pre></p> <p>Task1 stops at the next await after cancel(), runs cleanup, then raises CancelledError. Task2 continues normally.</p> <p>Here's a practical pattern for timeouts:</p> <pre><code>async def with_timeout():\n    try:\n        await asyncio.wait_for(long_running_task(\"TimedTask\"), timeout=3)\n    except asyncio.TimeoutError:\n        print(\"Task timed out!\")\n</code></pre> <p><code>wait_for()</code> automatically cancels the task if it exceeds the timeout.</p>"},{"location":"python-async/how-to-cancel-async-tasks-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Cancellation isn't immediate \u2014 tasks stop at their next <code>await</code>, not instantly. If your task is doing CPU work, it won't cancel until it hits an await.</li> <li>Must re-raise CancelledError \u2014 after cleanup, re-raise the exception. If you swallow it, asyncio thinks the task completed normally.</li> <li>gather() needs return_exceptions \u2014 without it, CancelledError propagates immediately, cancelling other tasks. Use <code>return_exceptions=True</code> to collect all results.</li> </ul>"},{"location":"python-async/how-to-cancel-async-tasks-in-python/#see-also","title":"See also","text":"<ul> <li>How to await multiple async tasks in Python?</li> <li>How to use asyncio in Python?</li> <li>External: https://docs.python.org/3/library/asyncio-task.html#task-cancellation</li> </ul>"},{"location":"python-async/how-to-create-async-functions-in-python/","title":"How to create async functions in Python?","text":"<p>In short</p> <p>Creating async functions is simple: replace <code>def</code> with <code>async def</code>. That's the syntax. Inside, use <code>await</code> to pause on other async operations. The function becomes a coroutine\u2014calling it returns a coroutine object that must be awaited. Structure your async functions like regular functions: parameters, docstrings, return values, type hints all work normally. The only difference: you can use <code>await</code> inside, and callers must await the result. Start with your I/O operations (API calls, database queries, file reads), make those async, then make the functions calling them async, and so on up the chain.</p> <p>Here's the anatomy of async functions:</p> <pre><code>import asyncio\nfrom typing import List, Dict\n\n# Basic async function\nasync def simple_async():\n    await asyncio.sleep(1)\n    return \"Done\"\n\n# Async function with parameters and type hints\nasync def fetch_user(user_id: int) -&gt; Dict[str, any]:\n    \"\"\"\n    Fetches user data from a database.\n\n    Args:\n        user_id: The user's ID\n\n    Returns:\n        Dictionary with user data\n    \"\"\"\n    print(f\"Fetching user {user_id}...\")\n    await asyncio.sleep(0.5)  # Simulates DB query\n    return {\"id\": user_id, \"name\": f\"User{user_id}\"}\n\n# Async function calling other async functions\nasync def get_users_batch(user_ids: List[int]) -&gt; List[Dict]:\n    \"\"\"Fetches multiple users concurrently\"\"\"\n    tasks = [fetch_user(uid) for uid in user_ids]\n    users = await asyncio.gather(*tasks)\n    return users\n\n# Async function with error handling\nasync def safe_fetch(user_id: int) -&gt; Dict[str, any]:\n    try:\n        return await fetch_user(user_id)\n    except Exception as e:\n        print(f\"Error fetching user {user_id}: {e}\")\n        return {\"id\": user_id, \"error\": str(e)}\n\n# Run it\nasync def main():\n    user = await fetch_user(123)\n    print(user)\n\n    users = await get_users_batch([1, 2, 3])\n    print(users)\n\nasyncio.run(main())\n</code></pre> <p>Every function that needs to await something must be async. It's contagious by design\u2014async spreads up the call chain.</p> <p>Here's the pattern: identify I/O points (network, disk, sleep), make those functions async with <code>async def</code> and <code>await</code>, then make their callers async, until you reach your entry point where you use <code>asyncio.run()</code>.</p>"},{"location":"python-async/how-to-create-async-functions-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Forgetting async def makes await illegal \u2014 using <code>await</code> in a regular function is a SyntaxError. The function signature must be <code>async def</code>.</li> <li>Async without await is wasteful \u2014 if your async function never uses <code>await</code>, it's pointless overhead. Just use a regular function.</li> <li>Return types are normal \u2014 don't return coroutines or awaitable objects unless you mean to. Return regular values\u2014asyncio handles the wrapping.</li> </ul>"},{"location":"python-async/how-to-create-async-functions-in-python/#see-also","title":"See also","text":"<ul> <li>What is async def in Python?</li> <li>How to call an async function in Python?</li> <li>External: https://docs.python.org/3/library/asyncio-task.html</li> </ul>"},{"location":"python-async/how-to-debug-async-python-code/","title":"How to debug async Python code?","text":"<p>In short</p> <p>Enable asyncio's debug mode with <code>asyncio.run(main(), debug=True)</code> or set <code>PYTHONASYNCIODEBUG=1</code> to catch common mistakes like unawaited coroutines or slow callbacks. Use <code>print()</code> strategically (or logging) to trace execution flow\u2014async makes stack traces confusing. For interactive debugging, <code>pdb</code> works but loses context when switching tasks. Better options: <code>aioconsole</code> for async REPL, or IDEs like PyCharm/VS Code with async-aware breakpoints. The key insight: async debugging is harder because execution jumps between tasks, so focus on logging task states and using debug mode warnings.</p> <p>Here are practical debugging techniques:</p> <pre><code>import asyncio\nimport logging\n\n# Enable detailed logging\nlogging.basicConfig(level=logging.DEBUG)\n\nasync def problematic_task(task_id):\n    print(f\"Task {task_id}: Starting\")\n    try:\n        await asyncio.sleep(1)\n        if task_id == 2:\n            raise ValueError(\"Task 2 failed!\")\n        print(f\"Task {task_id}: Completed\")\n    except Exception as e:\n        print(f\"Task {task_id}: Error - {e}\")\n        raise\n\nasync def main():\n    # Gather with return_exceptions to see all errors\n    results = await asyncio.gather(\n        problematic_task(1),\n        problematic_task(2),\n        problematic_task(3),\n        return_exceptions=True  # Don't stop on first error\n    )\n\n    for i, result in enumerate(results, 1):\n        if isinstance(result, Exception):\n            print(f\"Task {i} failed: {result}\")\n\n# Run with debug mode\nasyncio.run(main(), debug=True)\n</code></pre> <p>Debug mode will warn you about: - Coroutines that were never awaited - Tasks that take &gt;100ms (configurable) - Exceptions not retrieved from tasks</p> <p>Here's a lifesaver: use <code>asyncio.create_task()</code> with <code>name</code> parameter for easier tracking: <code>task = asyncio.create_task(fetch(), name=\"fetch_user\")</code>. Then errors show the task name.</p>"},{"location":"python-async/how-to-debug-async-python-code/#gotchas","title":"Gotchas","text":"<ul> <li>Stack traces are confusing \u2014 they show event loop internals, not just your code. Look for your function names buried in the trace.</li> <li>print() might interleave \u2014 multiple tasks can print simultaneously. Use logging with task IDs for clarity.</li> <li>Deadlocks are silent \u2014 if all tasks are waiting on each other, your program just hangs. Use <code>asyncio.wait_for(coro, timeout=5)</code> to add timeouts.</li> </ul>"},{"location":"python-async/how-to-debug-async-python-code/#see-also","title":"See also","text":"<ul> <li>How async works in Python?</li> <li>How to cancel async tasks in Python?</li> <li>External: https://docs.python.org/3/library/asyncio-dev.html</li> </ul>"},{"location":"python-async/how-to-use-async-await-in-python/","title":"How to use async await in Python?","text":"<p>In short</p> <p>Use <code>async def</code> to define a coroutine function, and <code>await</code> inside it to pause on other async operations. The pattern: <code>async def my_function():</code> creates the function, <code>await other_async()</code> pauses until <code>other_async()</code> completes. You can only use <code>await</code> inside <code>async def</code> functions\u2014it's a syntax error elsewhere. To run async code from normal Python, use <code>asyncio.run(my_function())</code>. Think of <code>async</code> as the declaration (\"this can pause\") and <code>await</code> as the action (\"pause here\"). They work together\u2014you rarely use one without the other.</p> <p>Here's a step-by-step guide to using async/await:</p> <pre><code>import asyncio\n\n# Step 1: Define async functions with 'async def'\nasync def fetch_user(user_id):\n    print(f\"Fetching user {user_id}...\")\n    await asyncio.sleep(1)  # Step 2: Use 'await' for async operations\n    return {\"id\": user_id, \"name\": f\"User{user_id}\"}\n\nasync def fetch_posts(user_id):\n    print(f\"Fetching posts for user {user_id}...\")\n    await asyncio.sleep(0.5)\n    return [f\"Post1\", f\"Post2\"]\n\n# Step 3: Compose async functions\nasync def get_user_data(user_id):\n    user = await fetch_user(user_id)  # Wait for user\n    posts = await fetch_posts(user_id)  # Then wait for posts\n    return {\"user\": user, \"posts\": posts}\n\n# Step 4: Run from synchronous code\nresult = asyncio.run(get_user_data(123))\nprint(result)\n</code></pre> <p>Output: <pre><code>Fetching user 123...\nFetching posts for user 123...\n{'user': {'id': 123, 'name': 'User123'}, 'posts': ['Post1', 'Post2']}\n</code></pre></p> <p>Each <code>await</code> pauses the current function until the awaited operation completes. The event loop can run other tasks during these pauses.</p> <p>Here's the key pattern: chain async functions with <code>await</code>, and run the top-level one with <code>asyncio.run()</code>. Don't try to call async functions like regular functions\u2014you'll get a coroutine object, not the result.</p>"},{"location":"python-async/how-to-use-async-await-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Forgetting await returns a coroutine \u2014 <code>result = fetch_user(1)</code> gives you a coroutine object, not the data. Always <code>await</code> async calls.</li> <li>Can't await in regular functions \u2014 using <code>await</code> outside <code>async def</code> is a SyntaxError. Convert the function to async or use <code>asyncio.run()</code>.</li> <li>Sequential awaits are sequential \u2014 <code>await a(); await b()</code> runs them one after another. Use <code>asyncio.gather(a(), b())</code> for concurrency.</li> </ul>"},{"location":"python-async/how-to-use-async-await-in-python/#see-also","title":"See also","text":"<ul> <li>What is async and await in Python?</li> <li>How to call an async function in Python?</li> <li>External: https://docs.python.org/3/library/asyncio-task.html</li> </ul>"},{"location":"python-async/how-to-use-async-generator-in-python/","title":"How to use async generator in Python?","text":"<p>In short</p> <p>An async generator is an async function that uses <code>yield</code> instead of <code>return</code>, letting you stream values asynchronously. Define with <code>async def</code>, yield values, and consume with <code>async for</code>. They're perfect for processing large datasets, streaming APIs, or reading files incrementally without blocking. Think of them like regular generators, but with async superpowers\u2014each <code>yield</code> is an await point where other tasks can run. Use them when you'd use a generator in sync code but need async I/O between yields.</p> <p>Here's how to create and use async generators:</p> <pre><code>import asyncio\n\n# Define an async generator\nasync def fetch_pages(n):\n    \"\"\"Streams page data one at a time\"\"\"\n    for page in range(1, n + 1):\n        print(f\"Fetching page {page}...\")\n        await asyncio.sleep(0.5)  # Simulates async I/O\n        yield {\"page\": page, \"data\": f\"Content {page}\"}\n\n# Consume with async for\nasync def main():\n    async for page_data in fetch_pages(3):\n        print(f\"Processing: {page_data}\")\n        # Do work with each page as it arrives\n\nasyncio.run(main())\n</code></pre> <p>Output: <pre><code>Fetching page 1...\nProcessing: {'page': 1, 'data': 'Content 1'}\nFetching page 2...\nProcessing: {'page': 2, 'data': 'Content 2'}\nFetching page 3...\nProcessing: {'page': 3, 'data': 'Content 3'}\n</code></pre></p> <p>Each iteration fetches and processes one page at a time. The generator pauses at <code>yield</code> and <code>await</code>, letting other tasks run in between.</p> <p>Here's a practical use case: streaming large CSV files or paginated API results without loading everything into memory. You process items as they arrive, reducing memory usage.</p>"},{"location":"python-async/how-to-use-async-generator-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Must use async for \u2014 regular <code>for</code> loops won't work with async generators. You'll get \"TypeError: 'async_generator' object is not iterable.\"</li> <li>Can't mix yield and return values \u2014 <code>return some_value</code> in an async generator raises StopAsyncIteration, but the value is lost. Use <code>yield</code> for all outputs.</li> <li>Error handling is tricky \u2014 exceptions in async generators can be hard to trace. Wrap the <code>async for</code> in try/except to catch them.</li> </ul>"},{"location":"python-async/how-to-use-async-generator-in-python/#see-also","title":"See also","text":"<ul> <li>How to use asyncio in Python?</li> <li>What is async function in Python?</li> <li>External: https://peps.python.org/pep-0525/</li> </ul>"},{"location":"python-async/how-to-use-asyncio-in-python/","title":"How to use asyncio in Python?","text":"<p>In short</p> <p>Start with <code>asyncio.run()</code> to execute your main async function. Define functions with <code>async def</code>, use <code>await</code> for I/O operations, and <code>asyncio.gather()</code> to run multiple tasks concurrently. The pattern is: create async functions, await them where needed, and let <code>asyncio.run()</code> handle the event loop. For real I/O, replace blocking libraries (like <code>requests</code>) with async alternatives (like <code>aiohttp</code>). The learning curve is steep at first, but the core pattern\u2014define with <code>async def</code>, pause with <code>await</code>\u2014becomes second nature quickly.</p> <p>Here's a complete example showing common asyncio patterns:</p> <pre><code>import asyncio\n\nasync def fetch_data(source, delay):\n    print(f\"Fetching from {source}...\")\n    await asyncio.sleep(delay)  # Simulates I/O\n    return f\"Data from {source}\"\n\nasync def main():\n    # Run tasks concurrently\n    results = await asyncio.gather(\n        fetch_data(\"API\", 2),\n        fetch_data(\"Database\", 1),\n        fetch_data(\"Cache\", 0.5)\n    )\n\n    for result in results:\n        print(result)\n\n# Entry point - runs the event loop\nasyncio.run(main())\n</code></pre> <p>Output: <pre><code>Fetching from API...\nFetching from Database...\nFetching from Cache...\nData from API\nData from Database\nData from Cache\n</code></pre></p> <p>All three <code>fetch_data</code> calls start immediately, run concurrently, and finish in ~2 seconds (not 3.5). <code>asyncio.gather()</code> waits for all of them and returns results in order.</p> <p>Here's what often confuses people: you need async-compatible libraries. Using <code>time.sleep()</code> or <code>requests.get()</code> will block the entire event loop\u2014use <code>asyncio.sleep()</code> and <code>aiohttp</code> instead.</p>"},{"location":"python-async/how-to-use-asyncio-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Don't call asyncio.run() twice \u2014 it creates a new event loop. Call it once at your program's entry point, not inside async functions.</li> <li>Use async libraries \u2014 regular I/O libraries will block. Look for async alternatives: <code>aiohttp</code> for HTTP, <code>aiofiles</code> for file I/O, <code>asyncpg</code> for PostgreSQL.</li> <li>Exception handling matters \u2014 if one task in <code>gather()</code> raises an exception, it cancels the others by default. Use <code>return_exceptions=True</code> to collect errors instead.</li> </ul>"},{"location":"python-async/how-to-use-asyncio-in-python/#see-also","title":"See also","text":"<ul> <li>What is asyncio in Python?</li> <li>How to use async await in Python?</li> <li>External: https://docs.python.org/3/library/asyncio-task.html</li> </ul>"},{"location":"python-async/is-asyncio-faster-than-threading/","title":"Is asyncio faster than threading?","text":"<p>In short</p> <p>For I/O-bound tasks, asyncio is usually faster and more scalable than threading. Asyncio has lower overhead (no thread creation cost), uses less memory (one event loop vs many threads), and scales better (10k+ concurrent tasks). Threading excels when you need to mix sync and async code or when using libraries that release the GIL (like NumPy). For CPU-bound work, neither helps\u2014both are limited by Python's GIL. Use multiprocessing instead. The practical rule: for modern async-first I/O code, choose asyncio. For existing sync code with occasional concurrency, threading is easier.</p> <p>Here's a performance comparison:</p> <pre><code>import asyncio\nimport threading\nimport time\n\n# Test: 1000 \"network requests\" (simulated with sleep)\n\n# Threading approach\ndef thread_task():\n    time.sleep(0.001)\n\ndef threading_test():\n    start = time.time()\n    threads = []\n    for _ in range(1000):\n        t = threading.Thread(target=thread_task)\n        t.start()\n        threads.append(t)\n    for t in threads:\n        t.join()\n    print(f\"Threading: {time.time() - start:.2f}s\")\n\n# Asyncio approach\nasync def async_task():\n    await asyncio.sleep(0.001)\n\nasync def asyncio_test():\n    start = time.time()\n    await asyncio.gather(*[async_task() for _ in range(1000)])\n    print(f\"Asyncio: {time.time() - start:.2f}s\")\n\nthreading_test()  # ~1-2 seconds (thread overhead)\nasyncio.run(asyncio_test())  # ~0.01 seconds (minimal overhead)\n</code></pre> <p>Asyncio wins dramatically for many small I/O tasks. Thread creation and context switching add significant overhead.</p> <p>Memory usage: 1000 threads \u2248 1-8 MB per thread = 1-8 GB. 1000 asyncio tasks \u2248 a few KB each = a few MB total. Asyncio is 100-1000x more memory efficient.</p> <p>Here's the nuance: for 10-50 tasks, threading is simpler and fast enough. At 100+ concurrent tasks, asyncio's benefits become obvious.</p>"},{"location":"python-async/is-asyncio-faster-than-threading/#gotchas","title":"Gotchas","text":"<ul> <li>Asyncio requires async libraries \u2014 if your libraries are sync-only, threading might be easier despite being slower.</li> <li>Threading is better for mixed workloads \u2014 if you have both CPU and I/O work, threads can handle both (though not optimally). Asyncio only helps with I/O.</li> <li>Startup time differs \u2014 asyncio has one-time loop startup cost. For short-lived scripts with few tasks, threading might finish first.</li> </ul>"},{"location":"python-async/is-asyncio-faster-than-threading/#see-also","title":"See also","text":"<ul> <li>Which is better threading or asyncio in Python?</li> <li>Can Python be multithreaded?</li> <li>External: https://superfastpython.com/asyncio-vs-threading/</li> </ul>"},{"location":"python-async/is-asyncio-part-of-python/","title":"Is asyncio part of Python?","text":"<p>In short</p> <p>Yes, <code>asyncio</code> is part of Python's standard library\u2014it's been included since Python 3.4 (released in 2014). You don't need to install anything extra; just <code>import asyncio</code> and you're ready to go. The API has improved significantly over the years (Python 3.7 added <code>asyncio.run()</code>, 3.11 made it faster), but the core has been stable and built-in for a decade now. It's as \"standard\" as <code>json</code> or <code>datetime</code>.</p>"},{"location":"python-async/is-asyncio-part-of-python/#example","title":"Example","text":"<p>You can verify it's built-in by importing without installation:</p> <pre><code>import asyncio\nimport sys\n\nprint(f\"Python version: {sys.version}\")\nprint(f\"asyncio location: {asyncio.__file__}\")\nprint(f\"asyncio version: {asyncio.__version__ if hasattr(asyncio, '__version__') else 'N/A'}\")\n\n# It just works - no pip install needed\nasync def hello():\n    await asyncio.sleep(0.1)\n    return \"asyncio is built-in!\"\n\nresult = asyncio.run(hello())\nprint(result)\n</code></pre> <p>Output: <pre><code>Python version: 3.11.x\nasyncio location: /usr/lib/python3.11/asyncio/__init__.py\nasyncio version: N/A\nasyncio is built-in!\n</code></pre></p> <p>The path shows it's in Python's standard library directory, not in site-packages where third-party libraries live.</p>"},{"location":"python-async/is-asyncio-part-of-python/#gotchas","title":"Gotchas","text":"<ul> <li>Python 3.4-3.6 have older asyncio APIs. Code using <code>asyncio.run()</code> won't work in Python 3.6 or earlier\u2014you'll need to use <code>loop.run_until_complete()</code> instead.</li> <li>Third-party async libraries exist (like Trio, Curio), but they're not replacements for asyncio\u2014they're alternatives with different design philosophies.</li> <li>asyncio doesn't include HTTP clients. For that, you need third-party libraries like <code>aiohttp</code> or <code>httpx</code>.</li> </ul>"},{"location":"python-async/is-asyncio-part-of-python/#see-also","title":"See also","text":"<ul> <li>What is asyncio in Python?</li> <li>How to use asyncio in Python?</li> <li>Python asyncio documentation</li> </ul>"},{"location":"python-async/is-foreach-async-in-python/","title":"Is foreach async in Python?","text":"<p>In short</p> <p>Python doesn't have a built-in \"foreach\" keyword\u2014it uses <code>for</code> loops. Regular <code>for</code> loops are synchronous and can't await. For async iteration, use <code>async for</code> with async iterators or generators. It looks like <code>async for item in async_generator():</code> and lets you await during each iteration. If you want to process items concurrently (like JS <code>Promise.all</code>), use <code>asyncio.gather()</code> or <code>asyncio.as_completed()</code> with list comprehension. Bottom line: regular <code>for</code> is sync, <code>async for</code> is async iteration, and <code>gather()</code> is concurrent processing. Choose based on whether you need sequential async or concurrent execution.</p> <p>Here's how async iteration works in Python:</p> <pre><code>import asyncio\n\n# Regular for loop (synchronous)\ndef sync_example():\n    for i in range(3):\n        print(f\"Sync: {i}\")\n    # Can't use await inside\n\n# async for with async generator\nasync def async_generator():\n    for i in range(3):\n        await asyncio.sleep(0.5)\n        yield i\n\nasync def async_for_example():\n    async for item in async_generator():\n        print(f\"Async for: {item}\")\n        # Can await here\n\n# Concurrent processing (like Promise.all)\nasync def concurrent_example():\n    async def process(i):\n        await asyncio.sleep(0.5)\n        return f\"Processed {i}\"\n\n    # All run concurrently\n    results = await asyncio.gather(*[process(i) for i in range(3)])\n    for result in results:\n        print(result)\n\nasyncio.run(async_for_example())  # Sequential async\nasyncio.run(concurrent_example())  # Concurrent\n</code></pre> <p><code>async for</code> processes items one at a time (but asynchronously). <code>asyncio.gather()</code> processes them all at once. Choose based on whether order and sequential processing matter.</p> <p>Here's what JS developers often look for: <code>items.forEach(async item =&gt; await process(item))</code> doesn't work in JS (common mistake), and Python avoids this trap. Use <code>gather()</code> for concurrent foreach.</p>"},{"location":"python-async/is-foreach-async-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>async for needs an async iterable \u2014 you can't use it with regular lists. Wrap in an async generator or use <code>asyncio.gather()</code> with a list comprehension.</li> <li>Order isn't guaranteed with gather() \u2014 results come back in completion order by default. Use <code>asyncio.gather()</code> (not <code>as_completed()</code>) to preserve order.</li> <li>Can't await in regular for \u2014 trying <code>for x in items: await foo()</code> is valid syntax, but the for loop itself doesn't cooperate with the event loop.</li> </ul>"},{"location":"python-async/is-foreach-async-in-python/#see-also","title":"See also","text":"<ul> <li>How to iterate over a list in Python?</li> <li>How to await multiple async tasks in Python?</li> <li>External: https://peps.python.org/pep-0492/#asynchronous-iterators-and-async-for</li> </ul>"},{"location":"python-async/is-javascript-async-like-python/","title":"Is JavaScript async like Python?","text":"<p>In short</p> <p>JavaScript and Python async look similar (<code>async</code>/<code>await</code> keywords in both), but the underlying models differ. JavaScript is async by default\u2014nearly everything returns a Promise. Python is sync by default\u2014you opt into async explicitly. JavaScript has a built-in event loop that's always running. Python's event loop (asyncio) must be started manually with <code>asyncio.run()</code>. Both use cooperative multitasking, but JavaScript feels more \"async native\" while Python treats it as an add-on. If you know JS async, Python async will feel familiar syntactically but require adjusting your mental model about when things are async.</p> <p>Here's a side-by-side comparison:</p> <pre><code>// JavaScript (async by default)\nasync function fetchData() {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    return data;\n}\n\n// Just call it - event loop always runs\nfetchData().then(data =&gt; console.log(data));\n</code></pre> <pre><code># Python (sync by default, opt-in async)\nimport asyncio\nimport aiohttp\n\nasync def fetch_data():\n    async with aiohttp.ClientSession() as session:\n        async with session.get('https://api.example.com/data') as response:\n            data = await response.json()\n            return data\n\n# Must explicitly run the event loop\nasyncio.run(fetch_data())\n</code></pre> <p>Both use <code>async</code>/<code>await</code>, but JavaScript's event loop runs automatically in the browser or Node.js. Python requires you to start the loop explicitly.</p> <p>Key difference: JavaScript's <code>setTimeout()</code>, fetch, and most I/O are async by default. Python's equivalents (<code>time.sleep()</code>, <code>requests</code>) are sync\u2014you need async versions (<code>asyncio.sleep()</code>, <code>aiohttp</code>).</p> <p>Here's what surprises JS developers in Python: you can't just <code>await</code> anything. The function and all its dependencies must be explicitly async. JavaScript is more permissive.</p>"},{"location":"python-async/is-javascript-async-like-python/#gotchas","title":"Gotchas","text":"<ul> <li>Different event loop lifecycle \u2014 JS event loop runs continuously, Python's must be started/stopped. You can't nest <code>asyncio.run()</code> calls.</li> <li>Library differences \u2014 JS has Promise-based APIs everywhere. Python requires finding async-compatible libraries.</li> <li>Error handling differs \u2014 JS uses Promise rejection, Python uses exceptions. Both work in try/catch (or try/except), but the propagation differs slightly.</li> </ul>"},{"location":"python-async/is-javascript-async-like-python/#see-also","title":"See also","text":"<ul> <li>How async works in Python?</li> <li>What is asyncio in Python?</li> <li>External: https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous</li> </ul>"},{"location":"python-async/is-python-asynchronous/","title":"Is Python asynchronous?","text":"<p>In short</p> <p>Python isn't asynchronous by default\u2014it's synchronous at its core. Code runs line by line, top to bottom. But Python supports asynchronous programming through <code>asyncio</code> and the <code>async</code>/<code>await</code> syntax (since Python 3.5). You opt into async when you need it. Think of it like a car: Python normally drives in one lane (sync), but you can enable features for lane-switching (async) when traffic (I/O waits) makes it worthwhile. Most Python code is still synchronous, and that's perfectly fine for most use cases.</p> <p>Here's a comparison showing the difference:</p> <pre><code>import time\nimport asyncio\n\n# Synchronous Python (default)\ndef sync_task():\n    print(\"Sync start\")\n    time.sleep(1)\n    print(\"Sync done\")\n\nsync_task()  # Blocks for 1 second\n\n# Asynchronous Python (opt-in)\nasync def async_task():\n    print(\"Async start\")\n    await asyncio.sleep(1)\n    print(\"Async done\")\n\nasyncio.run(async_task())  # Can yield during sleep\n</code></pre> <p>Both take about 1 second, but the async version can let other tasks run during the <code>await asyncio.sleep(1)</code>. Synchronous Python waits; asynchronous Python cooperates.</p> <p>Here's what people often miss: Python's Global Interpreter Lock (GIL) means only one thread executes Python bytecode at a time. Async isn't about parallelism\u2014it's about concurrency. You're not doing more work at once, just switching between waiting tasks efficiently.</p>"},{"location":"python-async/is-python-asynchronous/#gotchas","title":"Gotchas","text":"<ul> <li>Async is opt-in, not automatic \u2014 just importing <code>asyncio</code> doesn't make your code async. You need <code>async def</code> and <code>await</code> explicitly.</li> <li>Libraries must support async \u2014 using <code>requests</code> in async code still blocks. You need async-compatible libraries like <code>aiohttp</code> or <code>httpx</code>.</li> <li>Mixing sync and async is tricky \u2014 calling sync blocking code from async functions defeats the purpose. Use <code>asyncio.to_thread()</code> for unavoidable sync calls.</li> </ul>"},{"location":"python-async/is-python-asynchronous/#see-also","title":"See also","text":"<ul> <li>What is async in Python?</li> <li>Is Python synchronous or asynchronous?</li> <li>External: https://docs.python.org/3/library/asyncio.html</li> </ul>"},{"location":"python-async/is-python-single-threaded/","title":"Is Python single threaded?","text":"<p>In short</p> <p>Python can use multiple threads, but the Global Interpreter Lock (GIL) means only one thread executes Python bytecode at a time. So yes, Python is effectively single-threaded for CPU-bound work\u2014multiple threads won't speed up pure computation. But threads still help for I/O-bound tasks (network, disk) because the GIL releases during I/O waits. Think of it like a single-lane bridge: many cars (threads) can queue up, but only one crosses at a time. For true parallelism, you need multiprocessing, not threading.</p> <p>Here's a quick demonstration of threading behavior:</p> <pre><code>import threading\nimport time\n\ndef cpu_bound_task(n):\n    \"\"\"Lots of computation\"\"\"\n    count = 0\n    for i in range(n):\n        count += i ** 2\n    return count\n\nstart = time.time()\n\n# Sequential\ncpu_bound_task(10_000_000)\ncpu_bound_task(10_000_000)\nprint(f\"Sequential: {time.time() - start:.2f}s\")\n\n# Threaded\nstart = time.time()\nt1 = threading.Thread(target=cpu_bound_task, args=(10_000_000,))\nt2 = threading.Thread(target=cpu_bound_task, args=(10_000_000,))\nt1.start(); t2.start()\nt1.join(); t2.join()\nprint(f\"Threaded: {time.time() - start:.2f}s\")\n# Similar times due to GIL\n</code></pre> <p>Both approaches take roughly the same time because the GIL ensures only one thread runs Python code at once. Threading doesn't help with CPU-bound tasks\u2014sometimes it's even slower due to context switching overhead.</p> <p>Here's what surprises people: Python has threads, but the GIL serializes their execution. For I/O (waiting for APIs, files), threads work great. For computation (crunching numbers), use <code>multiprocessing</code> instead.</p>"},{"location":"python-async/is-python-single-threaded/#gotchas","title":"Gotchas","text":"<ul> <li>Threads won't speed up CPU work \u2014 due to the GIL, threading can't leverage multiple CPU cores for pure Python computation. Use <code>multiprocessing.Pool</code> for that.</li> <li>I/O-bound is the sweet spot \u2014 threads excel when waiting for network, disk, or user input. The GIL releases during I/O, letting other threads run.</li> <li>Not all Python is GIL-limited \u2014 NumPy, C extensions, and some libraries release the GIL, so threading can be effective there.</li> </ul>"},{"location":"python-async/is-python-single-threaded/#see-also","title":"See also","text":"<ul> <li>Can Python be multithreaded?</li> <li>Which is better threading or asyncio in Python?</li> <li>External: https://realpython.com/python-gil/</li> </ul>"},{"location":"python-async/is-python-synchronous-or-asynchronous/","title":"Is Python synchronous or asynchronous?","text":"<p>In short</p> <p>Python is synchronous by default, but it supports asynchronous programming when you opt in. Regular Python code executes line by line, blocking at each step until complete. When you use <code>async def</code> and <code>await</code>, you enable cooperative multitasking where tasks can voluntarily yield control during I/O waits. So the answer is: Python is fundamentally synchronous, but you can write asynchronous code when needed. It's not one or the other\u2014it's both, depending on how you write your code.</p> <p>Here's how both models work side by side:</p> <pre><code>import time\nimport asyncio\n\n# Synchronous execution\ndef task_sync(name, delay):\n    print(f\"{name} starting\")\n    time.sleep(delay)  # Blocks everything\n    print(f\"{name} done\")\n\ntask_sync(\"Task 1\", 2)\ntask_sync(\"Task 2\", 1)\n# Total time: ~3 seconds (sequential)\n\n# Asynchronous execution\nasync def task_async(name, delay):\n    print(f\"{name} starting\")\n    await asyncio.sleep(delay)  # Yields control\n    print(f\"{name} done\")\n\nasync def main():\n    await asyncio.gather(\n        task_async(\"Task A\", 2),\n        task_async(\"Task B\", 1)\n    )\n\nasyncio.run(main())\n# Total time: ~2 seconds (concurrent)\n</code></pre> <p>Synchronous code runs top-to-bottom with no interruptions. Asynchronous code can interleave tasks while waiting for I/O. Both are valid Python\u2014you choose based on your needs.</p> <p>Here's the key insight: Python's execution is sequential unless you explicitly make it cooperative with async/await. It's not like JavaScript, where async is deeply embedded in the language runtime.</p>"},{"location":"python-async/is-python-synchronous-or-asynchronous/#gotchas","title":"Gotchas","text":"<ul> <li>Synchronous is the default \u2014 if you don't use <code>async</code>/<code>await</code>, your code is synchronous. No surprises.</li> <li>You can't mix them carelessly \u2014 calling synchronous blocking code in an async function blocks the entire event loop. Use <code>loop.run_in_executor()</code> or <code>asyncio.to_thread()</code> to handle sync calls.</li> <li>Async doesn't mean parallel \u2014 Python's GIL means async code still runs one operation at a time. It's concurrent (interleaved), not parallel (simultaneous).</li> </ul>"},{"location":"python-async/is-python-synchronous-or-asynchronous/#see-also","title":"See also","text":"<ul> <li>Is Python asynchronous?</li> <li>How async works in Python?</li> <li>External: https://realpython.com/async-io-python/</li> </ul>"},{"location":"python-async/what-does-async-do-in-python/","title":"What does async do in Python?","text":"<p>In short</p> <p>The <code>async</code> keyword transforms a regular function into a coroutine\u2014a special type of function that can pause its execution with <code>await</code> and let other code run. It doesn't run the function in the background or make it parallel; instead, it makes the function cooperative, allowing it to voluntarily yield control. When you call an async function, it returns a coroutine object that needs to be awaited or run by an event loop. It's the foundation for Python's cooperative multitasking model.</p>"},{"location":"python-async/what-does-async-do-in-python/#example","title":"Example","text":"<p>Here's what happens when you use <code>async</code>:</p> <pre><code>import asyncio\n\nasync def greet(name):\n    print(f\"Hello, {name}!\")\n    await asyncio.sleep(1)\n    print(f\"Goodbye, {name}!\")\n    return f\"{name} greeted\"\n\n# Calling it directly returns a coroutine object\ncoro = greet(\"Alice\")\nprint(coro)  # &lt;coroutine object greet at 0x...&gt;\n\n# You need to await it or run it with asyncio.run()\nresult = asyncio.run(greet(\"Bob\"))\nprint(result)\n</code></pre> <p>Output: <pre><code>&lt;coroutine object greet at 0x...&gt;\nHello, Bob!\nGoodbye, Bob!\nBob greeted\n</code></pre></p> <p>The <code>async</code> keyword makes <code>greet()</code> return a coroutine instead of executing immediately. You must await it or use <code>asyncio.run()</code> to actually run it.</p>"},{"location":"python-async/what-does-async-do-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Forgetting to await gives you a coroutine object, not the result. Python 3.7+ will warn you: \"coroutine 'greet' was never awaited.\"</li> <li>async alone doesn't make code concurrent. You need to use <code>await asyncio.gather()</code> or <code>asyncio.create_task()</code> to run multiple coroutines concurrently.</li> <li>You can't use await outside async functions. Trying to call <code>await</code> in regular functions gives a SyntaxError.</li> </ul>"},{"location":"python-async/what-does-async-do-in-python/#see-also","title":"See also","text":"<ul> <li>What is async function in Python?</li> <li>What is async and await in Python?</li> <li>Python coroutines documentation</li> </ul>"},{"location":"python-async/what-is-a-decorator-in-python-async/","title":"What is a decorator in Python (in async context)?","text":"<p>In short</p> <p>Decorators are functions that wrap other functions to add behavior\u2014like logging, timing, or caching. With async functions, decorators work the same way, but they must preserve the async nature. An async decorator typically wraps an async function with another async function using <code>@wraps</code> from <code>functools</code>. Common async decorators: retry logic, rate limiting, timing, caching. The key rule: if decorating an async function, the wrapper should also be async (use <code>async def</code>). If decorating sync functions, use regular decorators. They're powerful for cross-cutting concerns without cluttering your core logic.</p> <p>Here's how to create async decorators:</p> <pre><code>import asyncio\nimport functools\nimport time\n\n# Async decorator for timing\ndef async_timer(func):\n    @functools.wraps(func)\n    async def wrapper(*args, **kwargs):\n        start = time.time()\n        result = await func(*args, **kwargs)\n        duration = time.time() - start\n        print(f\"{func.__name__} took {duration:.2f}s\")\n        return result\n    return wrapper\n\n# Async decorator for retries\ndef async_retry(max_attempts=3):\n    def decorator(func):\n        @functools.wraps(func)\n        async def wrapper(*args, **kwargs):\n            for attempt in range(max_attempts):\n                try:\n                    return await func(*args, **kwargs)\n                except Exception as e:\n                    if attempt == max_attempts - 1:\n                        raise\n                    print(f\"Attempt {attempt + 1} failed: {e}\")\n                    await asyncio.sleep(1)\n        return wrapper\n    return decorator\n\n# Usage\n@async_timer\n@async_retry(max_attempts=3)\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return \"Data\"\n\nasyncio.run(fetch_data())\n</code></pre> <p>Output: <pre><code>fetch_data took 1.00s\n</code></pre></p> <p>The decorators add timing and retry logic without modifying <code>fetch_data()</code>. Stack them to combine behaviors.</p> <p>Here's a common mistake: forgetting <code>async def</code> in the wrapper when decorating async functions. The decorator will work but won't be awaitable, breaking your async chain.</p>"},{"location":"python-async/what-is-a-decorator-in-python-async/#gotchas","title":"Gotchas","text":"<ul> <li>Must use async def for async decorators \u2014 if your wrapper isn't async, you can't await the decorated function properly.</li> <li>Order matters \u2014 decorators stack from bottom to top. <code>@timer @retry</code> applies retry first, then timing.</li> <li>functools.wraps is essential \u2014 without it, your decorated function loses its name, docstring, and other metadata. Always use it.</li> </ul>"},{"location":"python-async/what-is-a-decorator-in-python-async/#see-also","title":"See also","text":"<ul> <li>How to create async functions in Python?</li> <li>What is async function in Python?</li> <li>External: https://realpython.com/primer-on-python-decorators/</li> </ul>"},{"location":"python-async/what-is-async-and-await-in-python/","title":"What is async and await in Python?","text":"<p>In short</p> <p><code>async</code> and <code>await</code> are two keywords that work together to enable cooperative multitasking. <code>async</code> marks a function as asynchronous (a coroutine), and <code>await</code> is used inside that function to pause execution while waiting for another async operation to complete. Think of <code>async</code> as \"this function can take breaks\" and <code>await</code> as \"take a break here.\" While one task is waiting, the event loop can run other tasks. They're Python's answer to non-blocking I/O without the complexity of threads or callbacks.</p>"},{"location":"python-async/what-is-async-and-await-in-python/#example","title":"Example","text":"<p>Here's how they work together:</p> <pre><code>import asyncio\n\nasync def make_coffee():\n    print(\"Grinding beans...\")\n    await asyncio.sleep(2)  # Pause here - let other tasks run\n    print(\"Coffee ready!\")\n    return \"Coffee\"\n\nasync def make_toast():\n    print(\"Toasting bread...\")\n    await asyncio.sleep(1)  # Another pause point\n    print(\"Toast ready!\")\n    return \"Toast\"\n\nasync def make_breakfast():\n    # Run both concurrently\n    coffee, toast = await asyncio.gather(\n        make_coffee(),\n        make_toast()\n    )\n    print(f\"Breakfast: {coffee} and {toast}\")\n\nasyncio.run(make_breakfast())\n</code></pre> <p>Output: <pre><code>Grinding beans...\nToasting bread...\nToast ready!\nCoffee ready!\nBreakfast: Coffee and Toast\n</code></pre></p> <p>Toast finishes first even though coffee started first\u2014that's cooperative multitasking. Each <code>await</code> is a yield point where control can switch.</p>"},{"location":"python-async/what-is-async-and-await-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>await only works inside async functions. Using it in regular functions gives <code>SyntaxError: 'await' outside async function</code>.</li> <li>Not everything is awaitable. You can only await coroutines, tasks, and futures. Regular functions or objects will give a TypeError.</li> <li>Forgetting await on an async call means you get a coroutine object, not the result. Python will warn you: \"coroutine was never awaited.\"</li> </ul>"},{"location":"python-async/what-is-async-and-await-in-python/#see-also","title":"See also","text":"<ul> <li>How to use async await in Python?</li> <li>Why use async await in Python?</li> <li>Python asyncio documentation</li> </ul>"},{"location":"python-async/what-is-async-def-in-python/","title":"What is async def in Python?","text":"<p>In short</p> <p><code>async def</code> is the syntax for defining an asynchronous function (coroutine) in Python. It's just like <code>def</code>, but with <code>async</code> in front. When you use <code>async def</code>, Python knows this function can pause with <code>await</code> and play nice with other async code. The function signature looks the same\u2014parameters, type hints, docstrings all work normally\u2014but the behavior changes: calling it returns a coroutine object instead of executing immediately. It's the literal declaration that makes a function asynchronous.</p>"},{"location":"python-async/what-is-async-def-in-python/#example","title":"Example","text":"<p>Here's how <code>async def</code> looks in practice:</p> <pre><code>import asyncio\n\n# Regular function\ndef regular_greet(name):\n    return f\"Hello, {name}!\"\n\n# Async function - just add 'async' before 'def'\nasync def async_greet(name):\n    await asyncio.sleep(0.5)  # Can use await inside\n    return f\"Hello, {name}!\"\n\n# Usage\nprint(regular_greet(\"Alice\"))  # Hello, Alice!\n\n# Async version needs await or asyncio.run()\nresult = asyncio.run(async_greet(\"Bob\"))\nprint(result)  # Hello, Bob!\n</code></pre> <p>Output: <pre><code>Hello, Alice!\nHello, Bob!\n</code></pre></p> <p>The only syntactic difference is the <code>async</code> keyword, but it fundamentally changes how the function works\u2014it becomes a coroutine that must be awaited.</p>"},{"location":"python-async/what-is-async-def-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>You can't have a regular function and async function with the same name\u2014Python treats them differently, but it's confusing and leads to mistakes.</li> <li>async def without any await is legal but pointless. Python won't warn you, but you're adding async overhead with no benefit.</li> <li>Type hints work normally: <code>async def fetch(url: str) -&gt; dict:</code> is perfectly valid and recommended.</li> </ul>"},{"location":"python-async/what-is-async-def-in-python/#see-also","title":"See also","text":"<ul> <li>What is async function in Python?</li> <li>How to create async functions in Python?</li> <li>PEP 492 - Coroutines with async and await syntax</li> </ul>"},{"location":"python-async/what-is-async-function-in-python/","title":"What is async function in Python?","text":"<p>In short</p> <p>An async function is a function defined with <code>async def</code> instead of just <code>def</code>. It's technically called a coroutine function, and when you call it, you get a coroutine object that must be awaited or run by an event loop. Async functions can use <code>await</code> to pause and let other tasks run while waiting for I/O. They're the building blocks of asynchronous programming\u2014each one represents a task that can cooperate with others instead of blocking the whole program.</p>"},{"location":"python-async/what-is-async-function-in-python/#example","title":"Example","text":"<p>Here's a comparison between regular and async functions:</p> <pre><code>import asyncio\nimport time\n\ndef sync_function():\n    print(\"Sync: Starting\")\n    time.sleep(1)\n    print(\"Sync: Done\")\n    return \"Sync result\"\n\nasync def async_function():\n    print(\"Async: Starting\")\n    await asyncio.sleep(1)\n    print(\"Async: Done\")\n    return \"Async result\"\n\n# Regular function - just call it\nresult1 = sync_function()\nprint(result1)\n\n# Async function - need asyncio.run()\nresult2 = asyncio.run(async_function())\nprint(result2)\n</code></pre> <p>Output: <pre><code>Sync: Starting\nSync: Done\nSync result\nAsync: Starting\nAsync: Done\nAsync result\n</code></pre></p> <p>The difference: <code>sync_function()</code> blocks everything while sleeping, but <code>async_function()</code> can let other tasks run during the sleep.</p>"},{"location":"python-async/what-is-async-function-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Async functions aren't async all the way down. If you call a blocking sync function inside an async function, you still block the event loop. Use async libraries like <code>aiohttp</code> instead of <code>requests</code>.</li> <li>You can't await in a sync function. Once you go async, everything that calls it needs to be async too (it's \"contagious\").</li> <li>Async functions have overhead. For simple, fast operations, they're slower than regular functions. Use them when you're actually waiting for I/O.</li> </ul>"},{"location":"python-async/what-is-async-function-in-python/#see-also","title":"See also","text":"<ul> <li>How to create async functions in Python?</li> <li>How to call an async function in Python?</li> <li>Python coroutines documentation</li> </ul>"},{"location":"python-async/what-is-async-in-python/","title":"What is async in Python?","text":"<p>In short</p> <p><code>async</code> is a keyword in Python that marks a function as asynchronous, meaning it can pause its execution to let other tasks run while waiting for I/O operations (like API calls or file reads) to complete. Think of it like a chef who starts boiling water, then preps vegetables while waiting\u2014instead of standing idle. It doesn't make code faster by itself, but it lets your program do multiple things \"at the same time\" without blocking.</p>"},{"location":"python-async/what-is-async-in-python/#example","title":"Example","text":"<p>Here's how you define and use an async function:</p> <pre><code>import asyncio\n\nasync def fetch_data():\n    print(\"Starting fetch...\")\n    await asyncio.sleep(2)  # Simulates waiting for an API\n    print(\"Fetch complete!\")\n    return \"Data retrieved\"\n\n# Run the async function\nresult = asyncio.run(fetch_data())\nprint(result)\n</code></pre> <p>Output: <pre><code>Starting fetch...\nFetch complete!\nData retrieved\n</code></pre></p> <p>The <code>async</code> keyword tells Python \"this function can pause and resume.\" The <code>await</code> inside tells it \"pause here while this operation completes, but let other tasks run.\"</p>"},{"location":"python-async/what-is-async-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>You can't just call <code>fetch_data()</code> directly\u2014you need <code>asyncio.run()</code> or another event loop. Calling it without await returns a coroutine object, not the result.</li> <li><code>async</code> doesn't magically parallelize CPU-heavy work. It's designed for I/O-bound tasks (network, disk) where you're mostly waiting. For CPU-intensive tasks, use multiprocessing instead.</li> <li>Mixing sync and async code is tricky. If you call a blocking function inside an async function without proper handling, you'll block the entire event loop.</li> </ul>"},{"location":"python-async/what-is-async-in-python/#see-also","title":"See also","text":"<ul> <li>What does async do in Python?</li> <li>What is asyncio in Python?</li> <li>Python asyncio documentation</li> </ul>"},{"location":"python-async/what-is-asyncio-in-python/","title":"What is asyncio in Python?","text":"<p>In short</p> <p><code>asyncio</code> is Python's standard library for writing asynchronous code. It provides an event loop that manages async functions, letting you run multiple I/O-bound tasks concurrently without threads or multiprocessing. Think of it as a traffic controller for your async functions\u2014it decides when each task runs, pauses, and resumes. It's been part of the standard library since Python 3.4 and is the go-to tool for async web servers, API clients, and anything that spends time waiting.</p>"},{"location":"python-async/what-is-asyncio-in-python/#example","title":"Example","text":"<p>Here's a simple asyncio program that runs two tasks concurrently:</p> <pre><code>import asyncio\n\nasync def task_one():\n    print(\"Task 1: Starting\")\n    await asyncio.sleep(2)\n    print(\"Task 1: Done\")\n\nasync def task_two():\n    print(\"Task 2: Starting\")\n    await asyncio.sleep(1)\n    print(\"Task 2: Done\")\n\nasync def main():\n    await asyncio.gather(task_one(), task_two())\n\nasyncio.run(main())\n</code></pre> <p>Output: <pre><code>Task 1: Starting\nTask 2: Starting\nTask 2: Done\nTask 1: Done\n</code></pre></p> <p>Both tasks start immediately, but Task 2 finishes first because it sleeps for less time. The event loop switches between them while they're waiting.</p>"},{"location":"python-async/what-is-asyncio-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>asyncio.run() creates a new event loop each time. Don't call it inside another async function\u2014you'll get a \"RuntimeError: asyncio.run() cannot be called from a running event loop.\"</li> <li>Not all libraries are async-compatible. Using <code>requests</code> or <code>time.sleep()</code> in async code will block the event loop. Use <code>aiohttp</code> and <code>asyncio.sleep()</code> instead.</li> <li>Debugging async code is harder because stack traces show the event loop machinery, not just your code. Tools like <code>asyncio.run(debug=True)</code> help.</li> </ul>"},{"location":"python-async/what-is-asyncio-in-python/#see-also","title":"See also","text":"<ul> <li>How to use asyncio in Python?</li> <li>Is asyncio part of Python?</li> <li>Python asyncio documentation</li> </ul>"},{"location":"python-async/which-is-better-threading-or-asyncio/","title":"Which is better threading or asyncio in Python?","text":"<p>In short</p> <p>Neither is universally \"better\"\u2014it depends on your use case. Choose asyncio for: web servers, websockets, API-heavy apps, or 100+ concurrent I/O tasks. Choose threading for: quick parallelization of sync code, mixing CPU and I/O work, or when your libraries don't support async. Choose multiprocessing for: CPU-bound work. The deciding factors: scale (asyncio wins big), library ecosystem (threading works with everything), and code complexity (threading is simpler for beginners). If starting fresh with modern libraries, lean toward asyncio. If retrofitting existing code, threading is less disruptive.</p> <p>Here's a decision matrix:</p> <pre><code># Use asyncio when:\n# - Handling 100-10k concurrent connections\n# - Working with async-native libraries (aiohttp, asyncpg)\n# - Building web servers, chat apps, streaming services\n# - Memory efficiency matters\n\nimport asyncio\nimport aiohttp\n\nasync def fetch_many(urls):\n    async with aiohttp.ClientSession() as session:\n        tasks = [session.get(url) for url in urls]\n        responses = await asyncio.gather(*tasks)\n        return responses\n\n# Use threading when:\n# - Need 5-50 concurrent tasks max\n# - Libraries are sync-only (requests, sqlite3)\n# - Mixing I/O with CPU work\n# - Team isn't familiar with async\n\nimport threading\nimport requests\n\ndef fetch_one(url):\n    return requests.get(url).text\n\nthreads = []\nfor url in urls:\n    t = threading.Thread(target=fetch_one, args=(url,))\n    t.start()\n    threads.append(t)\n\nfor t in threads:\n    t.join()\n</code></pre> <p>Performance at scale: - 10 tasks: Threading is simpler, similar speed - 100 tasks: Asyncio starts winning - 1000+ tasks: Asyncio is dramatically better</p> <p>Memory at 1000 tasks: - Threading: ~1-8 GB (1-8 MB per thread) - Asyncio: ~10-50 MB (KB per task)</p> <p>Here's the pragmatic answer: if you're building something new and modern, invest in learning asyncio\u2014it's the future. If you need something working today with existing code, threading is faster to implement.</p>"},{"location":"python-async/which-is-better-threading-or-asyncio/#gotchas","title":"Gotchas","text":"<ul> <li>Don't mix them carelessly \u2014 running async code in threads or vice versa requires careful handling. Stick to one model per project if possible.</li> <li>Debugging is harder with asyncio \u2014 stack traces are more complex. Threading has better tooling support.</li> <li>Library lock-in matters \u2014 once you choose asyncio, you're committed to async libraries throughout. Threading works with everything.</li> </ul>"},{"location":"python-async/which-is-better-threading-or-asyncio/#see-also","title":"See also","text":"<ul> <li>Is asyncio faster than threading?</li> <li>Can Python be multithreaded?</li> <li>External: https://docs.python.org/3/library/asyncio-task.html</li> </ul>"},{"location":"python-async/why-use-async-await-in-python/","title":"Why use async await in Python?","text":"<p>In short</p> <p>Async/await makes asynchronous code look like synchronous code, which is way easier to read and maintain than callbacks or raw coroutines. Before async/await, you had nested callbacks (\"callback hell\") or complex generator-based coroutines. Now you write straightforward sequential-looking code that's actually concurrent. The syntax makes control flow obvious\u2014no more guessing where execution goes next. Use async/await when you need async I/O but want your code to remain readable. It's Python's answer to JavaScript's Promise hell, and it works beautifully for web servers, API clients, and any I/O-heavy application.</p> <p>Here's why async/await is better than alternatives:</p> <pre><code>import asyncio\n\n# Old way: callbacks (messy, hard to follow)\ndef fetch_old(callback):\n    def inner():\n        # Fetch data...\n        callback(data)\n    # Complex callback chaining\n\n# async/await way: clean and sequential\nasync def fetch_user(user_id):\n    user = await get_user_from_db(user_id)\n    posts = await get_posts_for_user(user_id)\n    comments = await get_comments_for_posts(posts)\n    return {\"user\": user, \"posts\": posts, \"comments\": comments}\n</code></pre> <p>The async/await version reads top-to-bottom like sync code, but it's fully asynchronous. No callback nesting, no loss of context. Each <code>await</code> is a clear \"wait here\" marker.</p> <p>Here's the insight: async/await doesn't change what you can do (you could do async before Python 3.5), but it makes it dramatically more pleasant. Code that was previously cryptic becomes maintainable.</p>"},{"location":"python-async/why-use-async-await-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Still need to learn the event loop \u2014 async/await is syntactic sugar. You still need to understand how asyncio works underneath.</li> <li>Infectious by design \u2014 once you go async, all callers need to be async too. You can't easily mix sync and async without adapting.</li> <li>Not a magic bullet \u2014 async/await doesn't make slow I/O fast. It just lets you do other things while waiting. If your I/O is slow, it's still slow.</li> </ul>"},{"location":"python-async/why-use-async-await-in-python/#see-also","title":"See also","text":"<ul> <li>What is async and await in Python?</li> <li>Why use async in Python?</li> <li>External: https://peps.python.org/pep-0492/</li> </ul>"},{"location":"python-async/why-use-async-in-python/","title":"Why use async in Python?","text":"<p>In short</p> <p>Use async when you're spending lots of time waiting\u2014for APIs, databases, file I/O, or network requests. Async lets you handle thousands of concurrent connections with minimal memory, making it perfect for web servers, chat apps, or data pipelines that call many APIs. The win: while one request waits for a response, others can progress. For CPU-bound work (calculations, data processing), async doesn't help\u2014use multiprocessing instead. The trade-off: async adds complexity, so only reach for it when I/O waits are your bottleneck. If your program spends &lt;50% of its time waiting, stick with sync code.</p> <p>Here's a dramatic comparison showing async's power:</p> <pre><code>import asyncio\nimport time\n\n# Synchronous version\ndef sync_fetch_all():\n    start = time.time()\n    for i in range(10):\n        time.sleep(0.5)  # Simulates API call\n    print(f\"Sync: {time.time() - start:.2f}s\")  # ~5 seconds\n\nsync_fetch_all()\n\n# Async version\nasync def async_fetch(n):\n    await asyncio.sleep(0.5)\n\nasync def async_fetch_all():\n    start = time.time()\n    await asyncio.gather(*[async_fetch(i) for i in range(10)])\n    print(f\"Async: {time.time() - start:.2f}s\")  # ~0.5 seconds\n\nasyncio.run(async_fetch_all())\n</code></pre> <p>The async version is 10x faster because all 10 \"API calls\" run concurrently. Sync waits for each one sequentially.</p> <p>Real-world win: a web scraper that fetches 1000 pages. Sync takes 1000 \u00d7 0.5s = 500s. Async with 100 concurrent tasks takes ~5s. That's a 100x speedup with the same hardware.</p> <p>Here's when NOT to use async: simple scripts, CPU-heavy computations, or when you're already using fast sync libraries. The debugging pain isn't worth it unless you're I/O-bound.</p>"},{"location":"python-async/why-use-async-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Async adds complexity \u2014 your code gets harder to read, debug, and test. Only use it when the performance gain justifies the cost.</li> <li>Library ecosystem matters \u2014 if your dependencies don't support async, you're forced to use slow workarounds. Check library support first.</li> <li>Scaling has limits \u2014 async handles 10k concurrent connections great, but each connection still consumes memory. Beyond ~50k, you need specialized tools.</li> </ul>"},{"location":"python-async/why-use-async-in-python/#see-also","title":"See also","text":"<ul> <li>Why use async await in Python?</li> <li>Why use asyncio in Python?</li> <li>External: https://realpython.com/async-io-python/</li> </ul>"},{"location":"python-async/why-use-asyncio-in-python/","title":"Why use asyncio in Python?","text":"<p>In short</p> <p>Use asyncio when you need to handle many I/O operations concurrently with minimal resource usage. It's lighter than threads (no overhead per task), more efficient than multiprocessing (no process spawning), and cleaner than callbacks. Perfect for web servers, websockets, database query batching, or scraping hundreds of websites. The sweet spot: 100-10,000 concurrent I/O operations. Below 100, regular sync code is simpler. Above 10k, you might need specialized tools. Asyncio gives you predictable, cooperative multitasking without the complexity of thread synchronization or the memory cost of processes.</p> <p>Here's when asyncio shines:</p> <pre><code>import asyncio\nimport aiohttp\n\n# Fetch 100 URLs concurrently with minimal memory\nasync def fetch_all_urls(urls):\n    async with aiohttp.ClientSession() as session:\n        tasks = []\n        for url in urls:\n            tasks.append(fetch_url(session, url))\n\n        # All requests run concurrently\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        return results\n\nasync def fetch_url(session, url):\n    async with session.get(url) as response:\n        return await response.text()\n\n# 100 requests, one event loop, minimal overhead\nurls = [f\"https://example.com/page/{i}\" for i in range(100)]\nasyncio.run(fetch_all_urls(urls))\n</code></pre> <p>With threads, you'd need 100 threads (expensive). With multiprocessing, 100 processes (very expensive). Asyncio handles all 100 with one thread and minimal memory.</p> <p>Real-world example: a chat server handling 10,000 connected users. Asyncio can manage all connections in one process. Threads would need 10,000 threads (too many), and multiprocessing is overkill.</p> <p>Here's the decision tree: CPU-bound? Use multiprocessing. A few I/O tasks? Use threads or stay sync. Hundreds/thousands of I/O tasks? Use asyncio.</p>"},{"location":"python-async/why-use-asyncio-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Learning curve is steep \u2014 asyncio's mental model is different from sync code. Budget time for learning.</li> <li>Ecosystem fragmentation \u2014 not all libraries support asyncio. You might need to find async alternatives or write wrappers.</li> <li>One blocking call ruins everything \u2014 a single <code>time.sleep()</code> or sync database call blocks the entire event loop. Vigilance required.</li> </ul>"},{"location":"python-async/why-use-asyncio-in-python/#see-also","title":"See also","text":"<ul> <li>Why use async in Python?</li> <li>Which is better threading or asyncio in Python?</li> <li>External: https://docs.python.org/3/library/asyncio.html</li> </ul>"},{"location":"python-lists/","title":"Python Lists","text":"<p>Everything you need to know about Python lists - from basics to advanced concepts. 34 in-depth articles covering creation, manipulation, iteration, performance, and comparisons.</p>"},{"location":"python-lists/#basics-fundamentals","title":"Basics &amp; Fundamentals","text":"<p>Start Here</p> <p>New to Python lists? These articles cover the foundational concepts.</p> <ul> <li>What is a Python list?</li> <li>What is a list in simple terms?</li> <li>Is a list a data type in Python?</li> <li>What are the three types of lists in Python?</li> </ul>"},{"location":"python-lists/#creating-initializing-lists","title":"Creating &amp; Initializing Lists","text":"<p>Multiple Ways to Create</p> <p>Learn various methods to create and initialize lists in Python.</p> <ul> <li>How do you create a list in Python?</li> <li>How do I declare a list in Python?</li> <li>How do I start or initialize a list in Python?</li> <li>What is list() in Python?</li> <li>How do you create lists using list comprehension?</li> </ul>"},{"location":"python-lists/#modifying-lists","title":"Modifying Lists","text":"<p>Mutability Matters</p> <p>Lists are mutable. Learn how to add, remove, and modify elements.</p> <ul> <li>How do I add items to a Python list?</li> <li>What does append() mean in Python?</li> <li>How do I remove elements from a Python list?</li> <li>How do I sort a list in Python?</li> </ul>"},{"location":"python-lists/#accessing-iterating","title":"Accessing &amp; Iterating","text":"<p>Working with Elements</p> <p>Access, slice, and loop through list items efficiently.</p> <ul> <li>How do you access elements in a Python list?</li> <li>What is [-1] in a Python list?</li> <li>How do you slice a list in Python?</li> <li>How do you iterate over a list in Python?</li> </ul>"},{"location":"python-lists/#list-operations","title":"List Operations","text":"<p>Combining &amp; Manipulating</p> <p>Advanced operations for working with multiple lists.</p> <ul> <li>What happens if you add two lists in Python?</li> <li>What does zip() do in Python?</li> <li>Can lists have duplicates in Python?</li> </ul>"},{"location":"python-lists/#when-to-use-lists","title":"When to Use Lists","text":"<p>Use Cases &amp; Best Practices</p> <p>Understand when lists are the right choice.</p> <ul> <li>What is the purpose of using a list in Python?</li> <li>When should you use a Python list?</li> <li>What is the main benefit of using lists in Python?</li> <li>When to use a list comprehension in Python?</li> </ul>"},{"location":"python-lists/#limitations-considerations","title":"Limitations &amp; Considerations","text":"<p>Performance &amp; Trade-offs</p> <p>Know the limitations and when to choose alternatives.</p> <ul> <li>What are the disadvantages of using lists in Python?</li> <li>How does list mutability affect performance?</li> <li>How do shallow and deep copies work in Python lists?</li> </ul>"},{"location":"python-lists/#lists-vs-other-data-structures","title":"Lists vs Other Data Structures","text":"<p>Comparison Guide</p> <p>Choose the right data structure for your needs.</p> <ul> <li>What is the difference between a tuple and a list?</li> <li>Are lists or dictionaries faster in Python?</li> <li>In what situations are lists preferred over dictionaries?</li> <li>When would you use a tuple instead of a list?</li> <li>Which is better \u2014 list or dictionary in Python?</li> <li>Is a NumPy array a list?</li> <li>When to use list vs tuple vs dictionary vs set in Python?</li> </ul> <p>:octicons-arrow-left-24: Back to Topics</p>"},{"location":"python-lists/are-lists-or-dictionaries-faster/","title":"Are lists or dictionaries faster in Python?","text":"<p>In short</p> <p>It depends on what kind of speed you care about. Dictionaries win when you look up items by key\u2014they use hashing, so it's almost instant. Lists are quick when you already know where the item is (by index). But for searching through a list to find something? That's where dicts shine. Memory-wise, dicts cost more because of hash table overhead. The pattern: use dicts when you search by key or ID, use lists when you process items in order or by position.</p> <p>In the following example, we check how long each takes to find a value in 10,000 items:</p> <pre><code>import time\n\n# Dictionary lookup (fast)\ndata_dict = {i: i**2 for i in range(10000)}\nstart = time.time()\nresult = 9999 in data_dict\ndict_time = time.time() - start\n\n# List lookup (slow)\ndata_list = list(range(10000))\nstart = time.time()\nresult = 9999 in data_list\nlist_time = time.time() - start\n\nprint(f\"Dict lookup: {dict_time:.6f}s\")\nprint(f\"List lookup: {list_time:.6f}s\")\nprint(f\"Dict is ~{list_time/dict_time:.0f}x faster\")\n</code></pre> <p>In the above code, the dictionary finishes much faster\u2014typically around 150x. That's because checking <code>9999 in data_dict</code> jumps straight to the hash key, while the list has to check each element one by one until it finds the match.</p>"},{"location":"python-lists/are-lists-or-dictionaries-faster/#gotchas","title":"Gotchas","text":"<ul> <li>Comparing them blindly isn't useful \u2014 they solve different problems. It's like asking \"is a knife faster than a spoon?\" Use each for what it's designed for.</li> <li>Memory trade-off \u2014 dicts use more RAM for that speed. For small datasets (&lt;100 items), the difference is negligible and readability should win.</li> <li>Dict order is now reliable \u2014 Python 3.7+ maintains insertion order in dicts, making them viable for some list-like use cases. But lists are still clearer when order is the main point.</li> </ul>"},{"location":"python-lists/are-lists-or-dictionaries-faster/#see-also","title":"See also","text":"<ul> <li>Which is better \u2014 list or dictionary in Python?</li> <li>When to use list vs tuple vs dictionary vs set in Python?</li> <li>External: https://wiki.python.org/moin/TimeComplexity</li> </ul>"},{"location":"python-lists/can-lists-have-duplicates-in-python/","title":"Can lists have duplicates in Python?","text":"<p>In short</p> <p>Absolutely, yes. Lists happily accept duplicates\u2014if you add the same item three times, you'll have it three times. That's by design. Unlike sets (which automatically kick out duplicates), lists preserve every single item you add, in order. So <code>[1, 1, 2]</code> and <code>[1, 2]</code> are completely different lists. This matters when you're collecting data from loops or tracking repeated events. If you later decide you want only unique items, you can convert to a set or use a comprehension to filter.</p> <p>In the following example, we create a list with duplicates and then show two ways to remove them:</p> <pre><code># Lists allow duplicates\nnumbers = [1, 2, 2, 3, 3, 3, 4]\nprint(numbers)\nprint(len(numbers))\n\n# Remove duplicates (loses order)\nunique = list(set(numbers))\nprint(unique)\n\n# Remove duplicates (keeps order)\nseen = []\n[seen.append(x) for x in numbers if x not in seen]\nprint(seen)\n</code></pre> <p>In the code above, the original list has 7 items including duplicates. Converting to a set removes them instantly, giving us <code>[1, 2, 3, 4]</code>, though the order might shuffle. The comprehension approach preserves the original sequence while removing duplicates.</p> <p>The gotcha? That <code>set()</code> trick is fast but might shuffle your order. If order matters, you need the slightly clunkier comprehension approach.</p>"},{"location":"python-lists/can-lists-have-duplicates-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Converting to set loses order \u2014 well, it used to always lose order. In Python 3.7+, sets actually maintain insertion order, but don't rely on it for critical logic. Use it when you don't care about sequence.</li> <li>Deduplicating is O(n\u00b2) the naive way \u2014 that <code>if x not in seen</code> check scans the whole list each time. For thousands of items, use a set for tracking: <code>seen_set = set()</code> then check against that.</li> <li>You can't dedupe nested lists \u2014 <code>set([1, [2, 3]])</code> crashes because lists aren't hashable. For complex data, you'll need custom logic or convert inner lists to tuples first.</li> </ul>"},{"location":"python-lists/can-lists-have-duplicates-in-python/#see-also","title":"See also","text":"<ul> <li>What is a Python list?</li> <li>When to use list vs tuple vs dictionary vs set in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#sets</li> </ul>"},{"location":"python-lists/create-lists-using-list-comprehension/","title":"How do you create lists using list comprehension?","text":"<p>In short</p> <p>List comprehensions let you build lists in one elegant line: <code>[expression for item in iterable]</code>. Want to filter? Add <code>if</code> at the end: <code>[x for x in range(10) if x % 2 == 0]</code>. They're faster than manually looping with <code>.append()</code> and way more readable for simple operations. You can even nest them for 2D structures: <code>[[x*y for x in range(3)] for y in range(3)]</code>. But here's the rule: if it doesn't fit comfortably on one line, use a regular loop. Comprehensions are about clarity, not code golf.</p> <p>Let's see comprehensions in action:</p> <pre><code># Basic comprehension\nsquares = [x**2 for x in range(5)]\n\n# With condition\nevens = [x for x in range(10) if x % 2 == 0]\n\n# Transform strings\nnames = [\"alice\", \"bob\"]\ncapitalized = [name.upper() for name in names]\n\n# Nested comprehension (2D)\nmatrix = [[i+j for j in range(3)] for i in range(3)]\n\nprint(squares)\nprint(evens)\nprint(matrix)\n</code></pre> <p>In the code above, the first comprehension gives us <code>[0, 1, 4, 9, 16]</code>. The filtered version produces <code>[0, 2, 4, 6, 8]</code>. And that nested one creates a 2D matrix: <code>[[0, 1, 2], [1, 2, 3], [2, 3, 4]]</code>.</p> <p>The nested one reads a bit backwards\u2014outer loop first, then inner. Takes getting used to.</p>"},{"location":"python-lists/create-lists-using-list-comprehension/#gotchas","title":"Gotchas","text":"<ul> <li>Don't get clever \u2014 if you need to squint to understand your comprehension, it's too complex. Use a regular loop. Readability beats brevity.</li> <li>The if-else dance \u2014 you can't write <code>[x if x &gt; 0 for x in items]</code>. It needs to be <code>[x if x &gt; 0 else 0 for x in items]</code> or <code>[x for x in items if x &gt; 0]</code>. The first replaces fails, the second filters them out.</li> <li>Nested comprehensions read weird \u2014 <code>[x for row in matrix for x in row]</code> flattens a 2D list. But the loops read inside-out compared to regular for loops. Takes practice.</li> </ul>"},{"location":"python-lists/create-lists-using-list-comprehension/#see-also","title":"See also","text":"<ul> <li>When to use a list comprehension in Python?</li> <li>How do you create a list in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions</li> </ul>"},{"location":"python-lists/difference-between-tuple-and-list/","title":"What is the difference between a tuple and a list?","text":"<p>In short</p> <p>The big one? Lists can change, tuples can't. Lists use square brackets <code>[]</code>, tuples use parentheses <code>()</code>. Once you create a tuple, it's frozen\u2014no adding, removing, or modifying items. Lists are your go-to for collections that evolve. Tuples signal \"this data is fixed\"\u2014like coordinates (x, y) or RGB colors. Tuples are slightly faster and use less memory, but honestly, for small stuff the difference is tiny. The real reason to pick tuples? You mean the data shouldn't change. Plus, tuples can be dictionary keys; lists can't.</p> <p>Let's see the difference in action:</p> <pre><code># List (mutable)\nmy_list = [1, 2, 3]\nmy_list.append(4)\nprint(my_list)\n\n# Tuple (immutable)\nmy_tuple = (1, 2, 3)\n# my_tuple.append(4)  # AttributeError!\nprint(my_tuple)\nprint(type(my_tuple))\n</code></pre> <p>In the code above, the list happily accepts a new item with <code>append</code>. But if you uncomment that tuple line, Python crashes with an error\u2014tuples don't have an <code>append</code> method because they can't be modified. The output shows <code>[1, 2, 3, 4]</code> for the list and <code>(1, 2, 3)</code> for the unchanged tuple.</p> <p>Here's the weird bit: <code>(1)</code> isn't a tuple, it's just an integer. You need a comma: <code>(1,)</code>. This catches everyone once.</p>"},{"location":"python-lists/difference-between-tuple-and-list/#gotchas","title":"Gotchas","text":"<ul> <li>Single-item tuple needs a comma \u2014 writing <code>(1)</code> just gives you the number 1 wrapped in parens. Write <code>(1,)</code> to make Python treat it as a tuple. Silly rule, but you'll remember after it bites you once.</li> <li>Tuples aren't fully immutable \u2014 if your tuple contains a list, you can still modify that list. The tuple's structure is locked, but mutable objects inside aren't magically frozen.</li> <li>Performance is overrated \u2014 yes, tuples are a hair faster. But for most code, readability and intent matter more. Choose tuples when you want to say \"don't touch this data\", not to squeeze out microseconds.</li> </ul>"},{"location":"python-lists/difference-between-tuple-and-list/#see-also","title":"See also","text":"<ul> <li>When would you use a tuple instead of a list?</li> <li>When to use list vs tuple vs dictionary vs set in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-lists/disadvantages-of-using-lists-in-python/","title":"What are the disadvantages of using lists in Python?","text":"<p>In short</p> <p>Lists are slow for searching\u2014checking <code>if item in list</code> walks through every element (O(n)). Inserting or deleting from the middle is also slow because Python has to shift everything. They use more memory than tuples or specialized structures because they over-allocate for growth. Lists aren't thread-safe, can't be dict keys (because they're mutable), and are terrible for numeric computation compared to NumPy arrays. They're general-purpose, which means they're not optimized for any specific use case. When performance matters, reach for specialized tools: sets for lookups, deques for queues, tuples for immutable data.</p> <p>Let me show you where lists struggle:</p> <pre><code># Slow lookup (O(n))\nlarge_list = list(range(100000))\nprint(50000 in large_list)  # Checks up to 50000 items\n\n# Slow insertion at start (O(n))\nitems = [1, 2, 3, 4, 5]\nitems.insert(0, 0)  # Shifts everything\n\n# Memory overhead\nimport sys\nprint(f\"List: {sys.getsizeof([1,2,3])} bytes\")\nprint(f\"Tuple: {sys.getsizeof((1,2,3))} bytes\")\n\n# Can't be dict keys\ntry:\n    d = {[1, 2]: \"value\"}\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n</code></pre> <p>Running this code, the lookup returns <code>True</code> but only after checking thousands of items. The list uses 80 bytes while the tuple only needs 64. And trying to use a list as a dict key fails with \"unhashable type: 'list'\".</p> <p>That 16-byte difference adds up when you're storing millions of small sequences.</p>"},{"location":"python-lists/disadvantages-of-using-lists-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Membership testing kills performance \u2014 for big lists, <code>x in list</code> is painfully slow. Switch to a set and get 100x+ speedup. Seriously, just use a set if you're checking membership often.</li> <li>Queue operations are wrong \u2014 <code>list.pop(0)</code> removes from the front but shifts everything (O(n)). Use <code>collections.deque</code> which has O(1) operations at both ends.</li> <li>Memory grows unpredictably \u2014 lists allocate extra capacity. For fixed-size numeric data, <code>array.array</code> or NumPy is way more memory-efficient.</li> </ul>"},{"location":"python-lists/disadvantages-of-using-lists-in-python/#see-also","title":"See also","text":"<ul> <li>What is the main benefit of using lists in Python?</li> <li>Are lists or dictionaries faster in Python?</li> <li>External: https://wiki.python.org/moin/TimeComplexity</li> </ul>"},{"location":"python-lists/how-to-access-elements-in-list/","title":"How do you access elements in a Python list?","text":"<p>In short</p> <p>Square brackets with the position: <code>my_list[0]</code> gets the first item. Python counts from zero, so <code>[0]</code> is first, <code>[1]</code> is second, and so on. Negative numbers count backwards: <code>[-1]</code> is last, <code>[-2]</code> is second-to-last. Try to access something that doesn't exist and you'll get an <code>IndexError</code>. To be safe, check the length first or use slicing (which doesn't crash on bad indices). It's simple once you remember: zero is the beginning, negatives work backwards from the end.</p> <p>Here's how indexing works in practice:</p> <pre><code># Basic indexing\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\n\nprint(fruits[0])    # First element\nprint(fruits[2])    # Third element\nprint(fruits[-1])   # Last element\nprint(fruits[-2])   # Second to last\n\n# Length check before accessing\nif len(fruits) &gt; 3:\n    print(fruits[3])\n</code></pre> <p>Running this code prints \"apple\" (first), \"cherry\" (third), \"date\" (last), and \"cherry\" again (second-to-last). The length check safely accesses index 3, which gives us \"date\".</p> <p>That negative indexing is genuinely handy\u2014no need to calculate <code>len(list) - 1</code> for the last item.</p>"},{"location":"python-lists/how-to-access-elements-in-list/#gotchas","title":"Gotchas","text":"<ul> <li>Zero-based indexing \u2014 this is the classic beginner stumble. The first item is <code>[0]</code>, not <code>[1]</code>. Coming from math or Excel, it feels wrong. You'll adjust.</li> <li>IndexError is common \u2014 accessing <code>list[5]</code> when there are only 3 items crashes hard. Always validate if you're unsure, or use try/except if you're feeling defensive.</li> <li>Negative indices aren't magic \u2014 <code>list[-100]</code> on a 3-item list still raises IndexError. Negatives just mean \"count from the end\", they don't wrap around infinitely or anything clever.</li> </ul>"},{"location":"python-lists/how-to-access-elements-in-list/#see-also","title":"See also","text":"<ul> <li>[What is [-1] in a Python list?]</li> <li>How do you slice a list in Python?</li> <li>External: https://docs.python.org/3/tutorial/introduction.html#lists</li> </ul>"},{"location":"python-lists/how-to-add-items-to-list/","title":"How do I add items to a Python list?","text":"<p>In short</p> <p>Most of the time, you just <code>.append(item)</code> to stick something on the end. Need it at a specific spot? <code>.insert(index, item)</code> works but pushes everything else over. Got multiple items to add? <code>.extend([items])</code> or <code>+=</code> dumps them all in at once. Want a new list instead of modifying the original? Use <code>+</code> concatenation: <code>new_list = old_list + [more_stuff]</code>. Append is your workhorse\u2014fast, simple, does what you expect. The others exist for when append isn't enough.</p> <p>Let's see each method in action:</p> <pre><code># Append single item\nfruits = [\"apple\", \"banana\"]\nfruits.append(\"cherry\")\nprint(fruits)\n\n# Insert at position\nfruits.insert(1, \"blueberry\")\nprint(fruits)\n\n# Extend with multiple items\nfruits.extend([\"date\", \"elderberry\"])\nprint(fruits)\n\n# Concatenation (creates new list)\nmore_fruits = fruits + [\"fig\", \"grape\"]\nprint(len(more_fruits))\n</code></pre> <p>In the example above, <code>append</code> adds \"cherry\" to the end, giving us <code>['apple', 'banana', 'cherry']</code>. Then <code>insert</code> squeezes \"blueberry\" into position 1, pushing everything else to the right. The <code>extend</code> method adds two more fruits in one go, and finally, the <code>+</code> operator creates a completely new list with 8 total items.</p>"},{"location":"python-lists/how-to-add-items-to-list/#gotchas","title":"Gotchas","text":"<ul> <li>append() vs extend() \u2014 this catches everyone once. <code>list.append([1, 2])</code> adds the entire list as one nested item, while <code>list.extend([1, 2])</code> unpacks and adds 1 and 2 individually. Big difference.</li> <li>insert() is slow \u2014 putting something at the front (index 0) means Python has to shift everything down. For lots of insertions at the start, use <code>collections.deque</code> instead.</li> <li>Concatenation copies \u2014 <code>list1 + list2</code> creates a brand new list. If you just want to modify <code>list1</code>, use <code>list1.extend(list2)</code> or <code>list1 += list2</code> instead. Saves memory.</li> </ul>"},{"location":"python-lists/how-to-add-items-to-list/#see-also","title":"See also","text":"<ul> <li>What does append() mean in Python?</li> <li>How do I remove elements from a Python list?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists</li> </ul>"},{"location":"python-lists/how-to-create-list-in-python/","title":"How do you create a list in Python?","text":"<p>In short</p> <p>The simplest way? Just write square brackets with stuff inside: <code>[1, 2, 3]</code>. For an empty list, use <code>[]</code> or <code>list()</code>. Need to convert something else into a list? Wrap it: <code>list(\"abc\")</code> turns a string into <code>['a', 'b', 'c']</code>. Want to generate values programmatically? List comprehensions are your friend: <code>[x*2 for x in range(5)]</code>. You can even use multiplication for repeating items: <code>[0] * 10</code> gives you ten zeros. All roads lead to the same destination\u2014a <code>list</code> object ready to use.</p> <p>Here are all the common ways to create lists:</p> <pre><code># Literal syntax\nfruits = [\"apple\", \"banana\", \"cherry\"]\n\n# Empty list\nempty = []\n\n# From other iterables\nfrom_string = list(\"hello\")\nfrom_range = list(range(5))\n\n# List comprehension\nsquares = [x**2 for x in range(5)]\n\nprint(fruits)\nprint(from_string)\nprint(squares)\n</code></pre> <p>In the above example, we create lists five different ways. The string \"hello\" becomes <code>['h', 'e', 'l', 'l', 'o']</code>, the range becomes <code>[0, 1, 2, 3, 4]</code>, and the comprehension gives us <code>[0, 1, 4, 9, 16]</code>.</p> <p>Watch out for the repetition trick though\u2014it has a gotcha with nested structures.</p>"},{"location":"python-lists/how-to-create-list-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Repetition with nested lists breaks \u2014 writing <code>[[]] * 3</code> creates three references to the same inner list. Change one, change all. Use <code>[[] for _ in range(3)]</code> instead to get independent lists.</li> <li>list() is optional \u2014 calling <code>list()</code> with no arguments gives you <code>[]</code>. The bracket syntax is more common and clearer. Save <code>list()</code> for when you're converting something.</li> <li>Strings explode into characters \u2014 <code>list(\"cat\")</code> becomes <code>['c', 'a', 't']</code>. If you wanted a list containing the string, write <code>[\"cat\"]</code> instead. Easy to mix up.</li> </ul>"},{"location":"python-lists/how-to-create-list-in-python/#see-also","title":"See also","text":"<ul> <li>How do I declare a list in Python?</li> <li>How do I start or initialize a list in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists</li> </ul>"},{"location":"python-lists/how-to-declare-list-in-python/","title":"How do I declare a list in Python?","text":"<p>In short</p> <p>Python doesn't do declarations like Java or C. You just... make the list. Write <code>my_list = [1, 2, 3]</code> and you're done. Want an empty one? <code>my_list = []</code>. That's it. The act of assigning creates the list\u2014no separate declaration step. If you're into type hints (optional but increasingly popular), you can write <code>my_list: list[int] = []</code> to signal \"this will hold integers.\" But Python won't enforce that at runtime. It's documentation for you and your IDE, not a strict rule.</p> <p>Here's how \"declaration\" works in Python:</p> <pre><code># Basic declaration (assignment)\nnumbers = [1, 2, 3, 4, 5]\n\n# Empty list declaration\nitems = []\n\n# With type hints (optional)\nnames: list[str] = [\"Alice\", \"Bob\"]\n\n# Verify they're all lists\nprint(type(numbers))\nprint(type(items))\nprint(names)\n</code></pre> <p>Running this code shows that all three approaches produce proper list objects. The output displays <code>&lt;class 'list'&gt;</code> for both <code>numbers</code> and <code>items</code>, and <code>['Alice', 'Bob']</code> for the names list.</p> <p>The confusion usually comes from other languages where you declare then assign. Python merges those into one step.</p>"},{"location":"python-lists/how-to-declare-list-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>No var/let/const keywords \u2014 if you're coming from JavaScript, forget <code>let</code> and <code>const</code>. Python just uses the variable name directly. It feels weird for about five minutes.</li> <li>Type hints are optional \u2014 they're great for readability and catching bugs with tools like mypy, but Python won't stop you from putting strings in a <code>list[int]</code>. They're hints, not contracts.</li> <li>Old vs new syntax \u2014 Python 3.9+ uses lowercase <code>list[int]</code>. Earlier versions needed <code>from typing import List</code> then <code>List[int]</code> (capital L). Modern code prefers the simpler lowercase version.</li> </ul>"},{"location":"python-lists/how-to-declare-list-in-python/#see-also","title":"See also","text":"<ul> <li>How do you create a list in Python?</li> <li>How do I start or initialize a list in Python?</li> <li>External: https://docs.python.org/3/library/typing.html</li> </ul>"},{"location":"python-lists/how-to-initialize-list-in-python/","title":"How do I start or initialize a list in Python?","text":"<p>In short</p> <p>Starting a list is dead simple: <code>my_list = []</code> for empty, or fill it upfront with <code>[0] * 5</code> for five zeros. Need something fancier? List comprehensions work great: <code>[i for i in range(10)]</code>. The one trap? Never use a list as a default function parameter like <code>def func(items=[]):</code>. That creates a single shared list across all calls\u2014classic Python gotcha. Instead, use <code>def func(items=None):</code> and check inside: <code>if items is None: items = []</code>. That gives each call its own fresh list.</p> <p>Here are the main ways to initialize lists:</p> <pre><code># Empty list\nempty = []\n\n# Pre-filled with same value\nzeros = [0] * 5\n\n# Sequential values\nnumbers = list(range(1, 6))\n\n# Complex initialization (2D list)\nmatrix = [[0 for _ in range(3)] for _ in range(3)]\n\nprint(zeros)\nprint(numbers)\nprint(matrix[0])\n</code></pre> <p>In the above code, the multiplication <code>[0] * 5</code> gives us <code>[0, 0, 0, 0, 0]</code>. The range becomes <code>[1, 2, 3, 4, 5]</code>. And that nested comprehension creates a 3x3 grid, with the first row showing as <code>[0, 0, 0]</code>.</p> <p>That matrix example shows proper 2D initialization. Don't use <code>[[0] * 3] * 3</code>\u2014it creates shared rows.</p>"},{"location":"python-lists/how-to-initialize-list-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Mutable default parameters are shared \u2014 writing <code>def add_item(items=[]):</code> means every call without arguments uses the same list. Add something once, it persists. Always use <code>None</code> as the default and create the list inside.</li> <li>Multiplication with nested structures \u2014 <code>[[0] * 3] * 3</code> looks fine but creates three references to the same inner list. Change one row, change all. Use nested comprehensions instead.</li> <li>Don't over-allocate \u2014 lists grow automatically. You rarely need to pre-fill with <code>[None] * 1000</code> unless you're doing something specific with indices. Start small and append as needed.</li> </ul>"},{"location":"python-lists/how-to-initialize-list-in-python/#see-also","title":"See also","text":"<ul> <li>How do you create a list in Python?</li> <li>How do I declare a list in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html</li> </ul>"},{"location":"python-lists/how-to-iterate-over-a-list/","title":"How do you iterate over a list in Python?","text":"<p>In short</p> <p>The Python way: <code>for item in my_list:</code>. Clean, readable, does what it says. Need the index too? <code>for i, item in enumerate(my_list):</code> gives you both. Only reach for while loops if you need to skip ahead or jump around dynamically. Coming from other languages, you might want to write <code>for i in range(len(my_list)):</code> but that's un-Pythonic\u2014iterate over items directly. For processing and transforming, list comprehensions often read better: <code>[process(x) for x in my_list]</code>. Simple patterns work best.</p> <p>Here are the main ways to loop through a list:</p> <pre><code>fruits = [\"apple\", \"banana\", \"cherry\"]\n\n# Basic iteration\nfor fruit in fruits:\n    print(fruit)\n\nprint(\"---\")\n\n# With index\nfor i, fruit in enumerate(fruits):\n    print(f\"{i}: {fruit}\")\n\nprint(\"---\")\n\n# While loop (less common)\ni = 0\nwhile i &lt; len(fruits):\n    print(fruits[i].upper())\n    i += 1\n</code></pre> <p>In the above example, the basic loop prints each fruit on its own line. The <code>enumerate()</code> version gives us numbered output: \"0: apple\", \"1: banana\", \"2: cherry\". And the while loop (which you'll rarely need) prints uppercased versions.</p> <p>See how the <code>enumerate()</code> version is cleaner than manually tracking an index variable.</p>"},{"location":"python-lists/how-to-iterate-over-a-list/#gotchas","title":"Gotchas","text":"<ul> <li>Don't modify while iterating \u2014 <code>for item in list: list.remove(item)</code> is a classic bug. The iterator gets confused as the list shrinks. Use a comprehension: <code>list = [x for x in list if keep(x)]</code>.</li> <li>Avoid range(len()) \u2014 <code>for i in range(len(list)):</code> works but screams \"I learned Python yesterday.\" Iterate directly over items or use <code>enumerate()</code> when you need indices.</li> <li>Iterators exhaust \u2014 if you convert to an iterator with <code>iter()</code>, you can only loop once. Lists themselves are iterable (not iterators) so you can loop multiple times safely.</li> </ul>"},{"location":"python-lists/how-to-iterate-over-a-list/#see-also","title":"See also","text":"<ul> <li>What does zip() do in Python?</li> <li>How do you create lists using list comprehension?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#looping-techniques</li> </ul>"},{"location":"python-lists/how-to-remove-elements-from-list/","title":"How do I remove elements from a Python list?","text":"<p>In short</p> <p><code>.remove(value)</code> finds and deletes the first matching item (crashes if not found). <code>.pop(index)</code> removes by position and hands you the item back (defaults to last if no index given). <code>del list[index]</code> or <code>del list[start:end]</code> nukes items by position or slice. <code>.clear()</code> empties the whole list. For removing items based on conditions, list comprehensions are cleaner: <code>[x for x in list if x != unwanted]</code>. Just remember: remove and pop change the list in-place, comprehensions give you a new one.</p> <p>Here are the main removal techniques:</p> <pre><code># Remove by value\nfruits = [\"apple\", \"banana\", \"cherry\", \"banana\"]\nfruits.remove(\"banana\")  # Removes first occurrence\nprint(fruits)\n\n# Pop by index (returns the item)\nlast = fruits.pop()\nprint(f\"Removed: {last}, Remaining: {fruits}\")\n\n# Delete by index or slice\nnumbers = [0, 1, 2, 3, 4]\ndel numbers[0]\ndel numbers[1:3]\nprint(numbers)\n\n# Filter with comprehension\nevens = [x for x in [1, 2, 3, 4, 5] if x % 2 == 0]\nprint(evens)\n</code></pre> <p>In the example above, <code>remove(\"banana\")</code> only kills the first \"banana\", leaving us <code>['apple', 'cherry', 'banana']</code>. The <code>pop()</code> removes and returns \"banana\", so <code>last</code> gets that value. After the <code>del</code> operations, <code>numbers</code> becomes <code>[1, 4]</code>. And the comprehension builds a fresh list: <code>[2, 4]</code>.</p> <p>Notice remove only got the first \"banana\"\u2014the second one stayed.</p>"},{"location":"python-lists/how-to-remove-elements-from-list/#gotchas","title":"Gotchas","text":"<ul> <li>remove() only removes once \u2014 got duplicates? It only kills the first match. To remove all, use a comprehension: <code>[x for x in list if x != target]</code>.</li> <li>Never modify while iterating \u2014 <code>for item in list: list.remove(item)</code> is a bug waiting to happen. The iterator gets confused as the list changes underneath it. Use comprehensions or iterate backwards with indices.</li> <li>pop() without index takes the last \u2014 <code>list.pop()</code> grabs from the end (stack behavior). Need the first? <code>list.pop(0)</code> works but is slow for big lists. Consider <code>collections.deque</code> if you're doing that a lot.</li> </ul>"},{"location":"python-lists/how-to-remove-elements-from-list/#see-also","title":"See also","text":"<ul> <li>How do I add items to a Python list?</li> <li>What does append() mean in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists</li> </ul>"},{"location":"python-lists/how-to-slice-a-list-in-python/","title":"How do you slice a list in Python?","text":"<p>In short</p> <p>Slicing pulls out chunks of a list with <code>[start:end:step]</code>. It includes the start position but stops before end. So <code>list[1:4]</code> gives you indices 1, 2, 3. Leave parts out for defaults: <code>[:3]</code> is first three, <code>[2:]</code> is everything from index 2 onward, <code>[:]</code> copies the whole thing. Negatives work: <code>[-3:]</code> grabs the last three items. The step lets you skip: <code>[::2]</code> is every other item, <code>[::-1]</code> reverses the list. Best part? Slicing never crashes\u2014bad indices just give you an empty list or clip to what exists.</p> <p>Here are some common slicing patterns:</p> <pre><code>numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Basic slicing\nprint(numbers[2:5])      # [2, 3, 4]\nprint(numbers[:4])       # First 4\nprint(numbers[6:])       # From 6 to end\n\n# With step\nprint(numbers[::2])      # Every other\nprint(numbers[1::2])     # Odd indices\n\n# Reverse\nprint(numbers[::-1])\n</code></pre> <p>Running the code above, <code>numbers[2:5]</code> extracts <code>[2, 3, 4]</code>, <code>[:4]</code> gives the first four <code>[0, 1, 2, 3]</code>, and <code>[6:]</code> gets everything from 6 onward. The step parameter <code>[::2]</code> picks every other element: <code>[0, 2, 4, 6, 8]</code>. And that <code>[::-1]</code> trick reverses the entire list.</p> <p>That <code>[::-1]</code> trick for reversing is a Python classic. Reads weird, works great.</p>"},{"location":"python-lists/how-to-slice-a-list-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>End is exclusive \u2014 <code>list[0:3]</code> gets 0, 1, 2. Not 0, 1, 2, 3. This trips up everyone at first. Think \"up to but not including.\"</li> <li>Out-of-range is safe \u2014 <code>list[100:200]</code> on a small list just gives <code>[]</code>. Unlike single indexing which crashes, slicing clips silently. Sometimes that's nice, sometimes it hides bugs.</li> <li>Shallow copy \u2014 <code>new = old[:]</code> copies the list structure but shares nested objects. Change a nested list in <code>new</code> and you'll see it in <code>old</code> too. For true independence, use <code>copy.deepcopy()</code>.</li> </ul>"},{"location":"python-lists/how-to-slice-a-list-in-python/#see-also","title":"See also","text":"<ul> <li>How do you access elements in a Python list?</li> <li>[What is [-1] in a Python list?]</li> <li>External: https://docs.python.org/3/tutorial/introduction.html#lists</li> </ul>"},{"location":"python-lists/how-to-sort-list-in-python/","title":"How do I sort a list in Python?","text":"<p>In short</p> <p>Two ways: <code>.sort()</code> modifies your list in-place (and returns nothing), while <code>sorted(list)</code> gives you a new sorted list and leaves the original alone. Both default to ascending order. Want descending? Add <code>reverse=True</code>. Need custom sorting, like by length? Use the <code>key</code> parameter: <code>.sort(key=len)</code>. Python's sort is seriously fast\u2014it uses Timsort, which is optimized for real-world data and runs in O(n log n). For most cases, just call <code>.sort()</code> and move on. It's stable too, meaning equal items keep their original order.</p> <p>Let me show you both approaches:</p> <pre><code># In-place sorting\nnumbers = [3, 1, 4, 1, 5]\nnumbers.sort()\nprint(numbers)\n\n# Create new sorted list\noriginal = [3, 1, 4]\nsorted_copy = sorted(original)\nprint(f\"Original: {original}, Sorted: {sorted_copy}\")\n\n# Reverse and custom key\nwords = [\"apple\", \"pie\", \"a\", \"cherry\"]\nwords.sort(key=len, reverse=True)\nprint(words)\n</code></pre> <p>In the code above, <code>numbers.sort()</code> modifies the list to <code>[1, 1, 3, 4, 5]</code>. The <code>sorted()</code> function creates a new list <code>[1, 3, 4]</code> while leaving <code>original</code> as <code>[3, 1, 4]</code>. That last example sorts by string length in descending order, giving us <code>['cherry', 'apple', 'pie', 'a']</code>.</p> <p>That key parameter is powerful\u2014you can sort by anything: string length, last character, whatever.</p>"},{"location":"python-lists/how-to-sort-list-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>sort() returns None \u2014 writing <code>result = my_list.sort()</code> makes <code>result</code> None. The sorting happens to the list itself. This is intentional Python design to prevent confusion about whether you got a new list or modified the old one.</li> <li>Can't sort mixed types \u2014 <code>[1, \"two\", 3].sort()</code> crashes in Python 3. Everything needs to be comparable. Strings compare to strings, numbers to numbers, but not across types.</li> <li>Key functions open up power \u2014 <code>key=str.lower</code> for case-insensitive sorting, <code>key=lambda x: x[1]</code> to sort tuples by their second element. Once you get comfortable with key functions, you'll use them everywhere.</li> </ul>"},{"location":"python-lists/how-to-sort-list-in-python/#see-also","title":"See also","text":"<ul> <li>What is a Python list?</li> <li>How do I add items to a Python list?</li> <li>External: https://docs.python.org/3/howto/sorting.html</li> </ul>"},{"location":"python-lists/is-list-a-data-type-in-python/","title":"Is a list a data type in Python?","text":"<p>In short</p> <p>Yes, absolutely. List is a built-in data type in Python, just like integers and strings. The difference? Lists are what we call \"compound\" or \"collection\" types\u2014they hold other things. When you ask Python <code>type([1, 2, 3])</code>, it tells you <code>&lt;class 'list'&gt;</code>. Lists belong to the sequence family, along with tuples and strings. Under the hood, they're dynamic arrays that can grow and shrink. So yes, a list is a first-class data type, and you'll use them constantly.</p> <p>Let me show you how to check this yourself:</p> <pre><code># Check the type of a list\nmy_list = [1, 2, 3]\nprint(type(my_list))\n\n# Verify it's an instance of list\nprint(isinstance(my_list, list))\n\n# Compare with other types\nprint(type(42))        # int\nprint(type(\"text\"))    # str\n</code></pre> <p>Running the above code confirms that lists are indeed a proper data type. The output shows <code>&lt;class 'list'&gt;</code>, and <code>isinstance</code> returns <code>True</code>. Notice how it's on equal footing with <code>int</code> and <code>str</code>\u2014they're all built-in Python types.</p> <p>What surprises people: lists are objects with methods like <code>.append()</code> and <code>.sort()</code>. They're not \"primitive\" like integers\u2014they're richer, more powerful, but also a bit heavier.</p>"},{"location":"python-lists/is-list-a-data-type-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Lists are objects, not primitives \u2014 this means they have methods you can call and they behave differently than simple numbers or booleans. They're more like little containers with their own behaviors.</li> <li>Type checking matters \u2014 when writing defensive code, use <code>isinstance(x, list)</code> instead of <code>type(x) == list</code>. It plays nicer with inheritance and subclasses.</li> <li>Don't confuse with arrays \u2014 Python lists aren't the same as C or Java arrays. Lists are more flexible (mixed types allowed) but potentially slower for massive numeric operations. For that, look at NumPy.</li> </ul>"},{"location":"python-lists/is-list-a-data-type-in-python/#see-also","title":"See also","text":"<ul> <li>What is a Python list?</li> <li>What are the three types of lists in Python?</li> <li>External: https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range</li> </ul>"},{"location":"python-lists/is-numpy-array-a-list/","title":"Is a NumPy array a list?","text":"<p>In short</p> <p>Nope. NumPy arrays are a completely different beast, even though they look similar. Arrays are fixed-type (all elements must be the same, like all floats), while lists accept mixed types. Arrays support vectorized math\u2014<code>array * 2</code> multiplies every element, but <code>list * 2</code> just repeats the list. Arrays are 10-100x faster for numeric work and use way less memory. Convert between them with <code>list(array)</code> or <code>np.array(list)</code>. Use arrays for math, science, and data work. Use lists for general Python programming. They're cousins, not twins.</p> <p>Let me show you the key differences:</p> <pre><code>import numpy as np\n\n# Python list\npy_list = [1, 2, 3, 4, 5]\n# py_list * 2  # Would give [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n\n# NumPy array\nnp_array = np.array([1, 2, 3, 4, 5])\ndoubled = np_array * 2  # Vectorized operation\nprint(doubled)\n\n# Different types\nprint(f\"List: {type(py_list)}\")\nprint(f\"Array: {type(np_array)}\")\nprint(f\"Array dtype: {np_array.dtype}\")\n\n# Convert back\nback_to_list = list(np_array)\nprint(back_to_list)\n</code></pre> <p>Running this code, the NumPy multiplication gives <code>[ 2  4  6  8 10]</code>\u2014each element doubled. The types show <code>&lt;class 'list'&gt;</code> vs <code>&lt;class 'numpy.ndarray'&gt;</code>. Converting back to a list produces <code>[1, 2, 3, 4, 5]</code>.</p> <p>That vectorization is the magic. No loops needed, just <code>* 2</code> and done.</p>"},{"location":"python-lists/is-numpy-array-a-list/#gotchas","title":"Gotchas","text":"<ul> <li>Type homogeneity \u2014 <code>np.array([1, 2.5])</code> converts everything to float. Lists happily mix types. Arrays sacrifice flexibility for speed.</li> <li>Different indexing \u2014 NumPy supports fancy indexing like <code>array[array &gt; 5]</code> (boolean masks). Lists don't do that.</li> <li>Memory layout \u2014 arrays are packed tightly in memory (cache-friendly), lists store pointers to scattered Python objects. That's why arrays are so much faster for math.</li> </ul>"},{"location":"python-lists/is-numpy-array-a-list/#see-also","title":"See also","text":"<ul> <li>What is a Python list?</li> <li>What are the disadvantages of using lists in Python?</li> <li>External: https://numpy.org/doc/stable/user/absolute_beginners.html</li> </ul>"},{"location":"python-lists/list-mutability-and-performance/","title":"How does list mutability affect performance?","text":"<p>In short</p> <p>Mutability enables fast in-place operations\u2014<code>.append()</code>, <code>.sort()</code>, <code>.reverse()</code> modify directly without copying, saving time and memory. But it's a double-edged sword. When functions might modify shared lists, you end up making defensive copies (<code>list.copy()</code>), which negates the speed benefit. Lists over-allocate memory for growth, using more RAM than tuples. For read-only data, tuples are lighter and enable optimizations. The trade-off: mutability gives you efficient modifications but at the cost of higher memory use and potential hidden copies when you need safety.</p> <p>Let me show you the trade-offs:</p> <pre><code>import sys\n\n# In-place modification (efficient)\nnumbers = [1, 2, 3, 4, 5]\nnumbers.reverse()  # O(n), no new list\nprint(numbers)\n\n# Memory comparison\nlist_obj = [1, 2, 3, 4, 5]\ntuple_obj = (1, 2, 3, 4, 5)\nprint(f\"List: {sys.getsizeof(list_obj)} bytes\")\nprint(f\"Tuple: {sys.getsizeof(tuple_obj)} bytes\")\n\n# Defensive copy cost\ndef process(items):\n    safe = items.copy()  # Extra work due to mutability\n    safe.sort()\n    return safe\n\nresult = process([3, 1, 2])\nprint(result)\n</code></pre> <p>In the code above, reversing the list happens instantly in-place: <code>[5, 4, 3, 2, 1]</code>. The memory check shows lists use 104 bytes vs tuples at 88 bytes\u2014that's the cost of flexibility. The function makes a defensive copy to avoid surprising mutations.</p> <p>That 16-byte difference is the cost of flexibility\u2014over-allocation for future growth.</p>"},{"location":"python-lists/list-mutability-and-performance/#gotchas","title":"Gotchas","text":"<ul> <li>Hidden copies everywhere \u2014 good defensive programming means copying mutable arguments. So you end up copying anyway, losing the modification speed benefit.</li> <li>Over-allocation compounds \u2014 lists pre-allocate ~12% extra space. For millions of small lists, that's real memory waste. Consider tuples or arrays for fixed data.</li> <li>Shared state bugs \u2014 <code>list2 = list1</code> creates a reference. Modify one, both change. This forces more copies than you'd need with immutable structures.</li> </ul>"},{"location":"python-lists/list-mutability-and-performance/#see-also","title":"See also","text":"<ul> <li>What are the disadvantages of using lists in Python?</li> <li>What is the difference between a tuple and a list?</li> <li>External: https://wiki.python.org/moin/TimeComplexity</li> </ul>"},{"location":"python-lists/list-vs-tuple-vs-dictionary-vs-set/","title":"When to use list vs tuple vs dictionary vs set in Python?","text":"<p>In short</p> <p>Lists for ordered, changeable sequences (your default). Tuples for fixed structures that shouldn't change. Dicts for key-value lookups. Sets for unique items with fast membership tests. Lists and tuples keep order; sets don't (though dicts do now in 3.7+). Lists and dicts are mutable; tuples are immutable. Ask yourself: Need order? Can it change? Looking up by key? Must items be unique? One question usually makes the choice obvious. When in doubt, start with a list and refactor if needed.</p> <p>Here's each structure in action:</p> <pre><code># List: ordered, mutable, duplicates OK\ntasks = [\"code\", \"test\", \"deploy\", \"test\"]\ntasks.append(\"monitor\")\nprint(f\"List: {tasks}\")\n\n# Tuple: immutable structure\npoint = (10, 20, 30)\nprint(f\"Tuple: {point}\")\n\n# Dict: key-value lookup\nconfig = {\"host\": \"localhost\", \"port\": 8080}\nprint(f\"Dict port: {config['port']}\")\n\n# Set: unique items, fast membership\ntags = {\"python\", \"coding\", \"python\"}  # Dup removed\nprint(f\"Set: {tags}\")\nprint(f\"'python' in set: {'python' in tags}\")\n</code></pre> <p>Running this shows how each behaves: the list keeps duplicates <code>['code', 'test', 'deploy', 'test', 'monitor']</code>, the tuple stays fixed at <code>(10, 20, 30)</code>, the dict provides instant lookup with <code>8080</code>, and the set automatically deduplicates to <code>{'coding', 'python'}</code>.</p> <p>Each has its lane. Use the right tool for the job.</p>"},{"location":"python-lists/list-vs-tuple-vs-dictionary-vs-set/#gotchas","title":"Gotchas","text":"<ul> <li>Sets lose order \u2014 don't rely on iteration order for sets, even though they technically maintain insertion order in modern Python. Use lists or dicts when order matters to your logic.</li> <li>Tuples for groups, lists for collections \u2014 use tuples for heterogeneous fixed-size data (coordinates, return values), lists for variable-size homogeneous sequences.</li> <li>Dict keys must be hashable \u2014 lists can't be dict keys, tuples can. That's a big practical difference.</li> </ul>"},{"location":"python-lists/list-vs-tuple-vs-dictionary-vs-set/#see-also","title":"See also","text":"<ul> <li>What is the difference between a tuple and a list?</li> <li>Which is better \u2014 list or dictionary in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html</li> </ul>"},{"location":"python-lists/main-benefit-of-using-lists-in-python/","title":"What is the main benefit of using lists in Python?","text":"<p>In short</p> <p>Flexibility. Lists grow, shrink, and change without you worrying about size or type (though mixing types is usually a bad idea). They're mutable but ordered, simple but powerful. You get fast position-based access, tons of built-in methods (append, sort, reverse), and they work everywhere in Python. Lists don't require upfront size declarations or type specifications\u2014just start with <code>[]</code> and build as you go. They're the Swiss Army knife of data structures: not always the absolute best tool, but good enough for most jobs and familiar to everyone.</p> <p>Here's flexibility in action:</p> <pre><code># Flexibility in action\ndata = []\n\n# Grow dynamically\nfor i in range(5):\n    data.append(i)\n\n# Mixed types (works, but usually avoid)\ndata.append(\"text\")\ndata.append([1, 2])\n\n# Built-in operations\ndata.sort(key=str)  # Sort using string representation\nprint(data)\n\n# Fast access\nprint(f\"First: {data[0]}, Last: {data[-1]}\")\n</code></pre> <p>In the code above, we start empty and build up <code>[0, 1, 2, 3, 4, 'text', [1, 2]]</code>. The sort works by converting everything to strings. We get instant access to first and last elements.</p> <p>That mix of types works but makes the code harder to reason about. Stick to one type when you can.</p>"},{"location":"python-lists/main-benefit-of-using-lists-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Flexibility can bite \u2014 just because you can mix strings, numbers, and nested lists doesn't mean you should. Homogeneous lists are easier to work with and less prone to bugs.</li> <li>Not always fastest \u2014 sets beat lists for membership tests, deques win for queue operations, NumPy arrays crush lists for numeric math. Lists trade peak performance for versatility.</li> <li>Mutability cuts both ways \u2014 easy to change is great until you accidentally modify shared state. If data shouldn't change, use a tuple to enforce it.</li> </ul>"},{"location":"python-lists/main-benefit-of-using-lists-in-python/#see-also","title":"See also","text":"<ul> <li>What is the purpose of using a list in Python?</li> <li>What are the disadvantages of using lists in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists</li> </ul>"},{"location":"python-lists/purpose-of-using-list-in-python/","title":"What is the purpose of using a list in Python?","text":"<p>In short</p> <p>Lists exist to hold multiple things in one place without juggling separate variables. Need to collect results from a loop? List. Processing a batch of user inputs? List. Building a queue or tracking history? List. They shine when you need ordered storage that can grow or shrink on the fly. You don't have to know upfront how many items you'll have\u2014just start with an empty list and append as you go. Think of them as your default \"bunch of stuff\" container when the order matters and things might change.</p> <p>Here's a typical use case\u2014collecting results as you process data:</p> <pre><code># Collect results from a loop\nsquares = []\nfor i in range(1, 6):\n    squares.append(i ** 2)\nprint(squares)\n\n# Process items in order\nscores = [85, 92, 78, 90]\naverage = sum(scores) / len(scores)\nprint(f\"Average: {average}\")\n</code></pre> <p>In the above example, we start with an empty list and build it up during the loop, ending with <code>[1, 4, 9, 16, 25]</code>. Then we process a batch of scores to calculate an average. Lists make both patterns simple and readable.</p> <p>The trick is knowing when not to use a list. If you're constantly searching for specific items, you probably want a dictionary or set instead.</p>"},{"location":"python-lists/purpose-of-using-list-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Not your hammer for every nail \u2014 if you find yourself doing <code>[x for x in list if x.id == target_id]</code>, stop. Use a dictionary with IDs as keys. Lists are O(n) for lookups, which hurts fast.</li> <li>Memory overhead exists \u2014 lists pre-allocate extra space to grow efficiently. For millions of tiny lists, that adds up. Consider alternatives like generators or NumPy arrays for huge numeric datasets.</li> <li>Don't fake other data structures \u2014 yes, you can use a list as a queue by popping index 0. But <code>collections.deque</code> exists for a reason\u2014it's way faster for that pattern.</li> </ul>"},{"location":"python-lists/purpose-of-using-list-in-python/#see-also","title":"See also","text":"<ul> <li>When should you use a Python list?</li> <li>What is the main benefit of using lists in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists</li> </ul>"},{"location":"python-lists/shallow-and-deep-copies-in-lists/","title":"How do shallow and deep copies work in Python lists?","text":"<p>In short</p> <p>Shallow copy creates a new list but shares the objects inside\u2014use <code>list.copy()</code>, <code>list[:]</code>, or <code>list(original)</code>. Deep copy recursively copies everything, including nested objects\u2014use <code>copy.deepcopy()</code>. For simple lists of immutable stuff (numbers, strings), shallow is fine and fast. But for lists containing mutable objects (other lists, dicts), shallow copies share those inner objects\u2014change one, see it in both. Deep copies are slower but give true independence. Most of the time shallow is enough. Reach for deep only when you have nested structures and need full separation.</p> <p>Let me show you the critical difference:</p> <pre><code>import copy\n\n# Shallow copy: inner lists are shared\noriginal = [[1, 2], [3, 4]]\nshallow = original.copy()\nshallow[0][0] = 99  # Modifies original too!\nprint(f\"Original: {original}\")\nprint(f\"Shallow: {shallow}\")\n\nprint(\"---\")\n\n# Deep copy: completely independent\noriginal2 = [[1, 2], [3, 4]]\ndeep = copy.deepcopy(original2)\ndeep[0][0] = 99\nprint(f\"Original2: {original2}\")\nprint(f\"Deep: {deep}\")\n</code></pre> <p>Running this code, the shallow copy shows <code>[[99, 2], [3, 4]]</code> for both original and copy\u2014the inner lists are shared! But the deep copy keeps <code>original2</code> as <code>[[1, 2], [3, 4]]</code> while only <code>deep</code> becomes <code>[[99, 2], [3, 4]]</code>. Complete independence.</p> <p>See how the shallow copy's change bled through to the original? That's the gotcha.</p>"},{"location":"python-lists/shallow-and-deep-copies-in-lists/#gotchas","title":"Gotchas","text":"<ul> <li>Assignment isn't copying \u2014 <code>list2 = list1</code> creates a reference, not a copy. Both names point to the same list. Always use <code>.copy()</code> when you want independence.</li> <li>Shallow fails with nesting \u2014 for 2D lists, shallow copy only copies the outer list. The inner lists are still shared. This catches people constantly.</li> <li>Deep copy is expensive \u2014 it traverses and copies everything recursively. For huge nested structures, this can be slow and memory-hungry. Use only when you truly need it.</li> </ul>"},{"location":"python-lists/shallow-and-deep-copies-in-lists/#see-also","title":"See also","text":"<ul> <li>What is a Python list?</li> <li>How does list mutability affect performance?</li> <li>External: https://docs.python.org/3/library/copy.html</li> </ul>"},{"location":"python-lists/three-types-of-lists-in-python/","title":"What are the three types of lists in Python?","text":"<p>In short</p> <p>Here's the thing: Python doesn't actually have three different \"types\" of lists. There's just one\u2014the <code>list</code> type. What the question probably means is the three main ways to create lists. You can write them literally with square brackets, use the <code>list()</code> constructor to convert other stuff, or generate them with list comprehensions. All three give you the exact same kind of object. Some people also talk about nested lists vs flat lists, but that's about content, not type. Bottom line: one list type, multiple ways to make it.</p> <p>Let me show you all three creation methods:</p> <pre><code># 1. Literal syntax\nlist1 = [1, 2, 3]\n\n# 2. list() constructor\nlist2 = list(range(1, 4))\n\n# 3. List comprehension\nlist3 = [x for x in range(1, 4)]\n\nprint(list1 == list2 == list3)  # All identical\nprint(type(list1))\n</code></pre> <p>Running this code proves they're all the same. The output shows <code>True</code> (they're equal) and <code>&lt;class 'list'&gt;</code> for the type. They all produce identical results\u2014the syntax changes, but the type doesn't.</p> <p>They all produce identical results. The syntax changes, but the type doesn't. Choose based on readability and what you're doing.</p>"},{"location":"python-lists/three-types-of-lists-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>No official \"three types\" \u2014 if someone insists there are three types of lists, they're probably confused. It's one type, different creation patterns. Or they might mean list/tuple/range, which are different data types entirely.</li> <li>List comprehensions aren't a type \u2014 they're just syntactic sugar for building lists. Under the hood, Python creates a regular old list object. The comprehension is gone once the list exists.</li> <li>Don't overthink it \u2014 at runtime, Python doesn't care how you made the list. <code>[1, 2, 3]</code> and <code>list([1, 2, 3])</code> are functionally identical. Pick what reads best.</li> </ul>"},{"location":"python-lists/three-types-of-lists-in-python/#see-also","title":"See also","text":"<ul> <li>How do you create a list in Python?</li> <li>How do you create lists using list comprehension?</li> <li>External: https://docs.python.org/3/library/stdtypes.html#list</li> </ul>"},{"location":"python-lists/what-does-append-mean-in-python/","title":"What does append() mean in Python?","text":"<p>In short</p> <p><code>.append()</code> sticks one item onto the end of your list. That's it. It modifies the list in-place and doesn't return anything (well, it returns <code>None</code>, but you ignore that). Need to build a list in a loop? Append is your friend\u2014it's fast, averaging O(1) time. The catch: it takes exactly one thing. Pass it a list and that whole list becomes a single nested element. Most beginners do that once, see the weird result, and never make the mistake again. For multiple items, you want <code>.extend()</code> instead.</p> <p>Let me show you how append works:</p> <pre><code># Basic append\nnumbers = [1, 2, 3]\nnumbers.append(4)\nprint(numbers)\n\n# Append in a loop\nsquares = []\nfor i in range(5):\n    squares.append(i**2)\nprint(squares)\n\n# Appending a list creates nesting\nitems = [1, 2]\nitems.append([3, 4])\nprint(items)  # Note: [3, 4] is one element\n</code></pre> <p>In the example above, the first append gives us <code>[1, 2, 3, 4]</code>. The loop builds up <code>[0, 1, 4, 9, 16]</code> one square at a time. But that last one? It creates <code>[1, 2, [3, 4]]</code>\u2014the list <code>[3, 4]</code> became a single nested item, not two separate numbers.</p> <p>See that last one? <code>[3, 4]</code> became a single nested item, not two separate numbers.</p>"},{"location":"python-lists/what-does-append-mean-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Returns None \u2014 writing <code>result = my_list.append(5)</code> makes <code>result</code> equal to <code>None</code>. Append modifies the list and returns nothing useful. This trips up folks coming from JavaScript or other languages.</li> <li>Only one argument \u2014 <code>my_list.append(1, 2)</code> throws an error. If you've got multiple things, either append them one by one in a loop or use <code>.extend([1, 2])</code>.</li> <li>In-place modification \u2014 pass a list to a function that appends to it? The original list changes. Sometimes that's what you want, sometimes it's a nasty surprise. Make a copy first if you need the original intact.</li> </ul>"},{"location":"python-lists/what-does-append-mean-in-python/#see-also","title":"See also","text":"<ul> <li>How do I add items to a Python list?</li> <li>How do I remove elements from a Python list?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists</li> </ul>"},{"location":"python-lists/what-does-zip-do-in-python/","title":"What does zip() do in Python?","text":"<p>In short</p> <p><code>zip()</code> pairs up items from two or more lists (or any iterables) position by position. Give it <code>[1, 2, 3]</code> and <code>['a', 'b', 'c']</code>, and you get tuples: <code>(1, 'a')</code>, <code>(2, 'b')</code>, <code>(3, 'c')</code>. It stops when the shortest list runs out. Perfect for iterating over multiple lists in parallel or creating dictionaries from separate key and value lists. The result is an iterator, so wrap it in <code>list()</code> if you need to see or reuse the full output. Think of it as a zipper joining two sides together\u2014hence the name.</p> <p>Here's how you'd typically use zip:</p> <pre><code># Basic zipping\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nages = [25, 30, 35]\ncombined = list(zip(names, ages))\nprint(combined)\n\n# Create dictionary\nperson_dict = dict(zip(names, ages))\nprint(person_dict)\n\n# Parallel iteration\nfor name, age in zip(names, ages):\n    print(f\"{name} is {age} years old\")\n</code></pre> <p>Running the code above produces <code>[('Alice', 25), ('Bob', 30), ('Charlie', 35)]</code> as a list of tuples. Converting to a dict gives us <code>{'Alice': 25, 'Bob': 30, 'Charlie': 35}</code>. And the loop prints each person's name with their age on separate lines.</p> <p>That dict creation is elegant\u2014two lists become a dictionary in one line.</p>"},{"location":"python-lists/what-does-zip-do-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Stops at shortest \u2014 <code>zip([1, 2, 3], ['a'])</code> only produces <code>(1, 'a')</code>. The extra 2 and 3 get ignored. If you need all items, use <code>itertools.zip_longest()</code> which pads with None.</li> <li>Returns iterator in Python 3 \u2014 you can only loop through it once. If you need to use it multiple times, convert to a list first: <code>list(zip(...))</code>.</li> <li>Unzipping trick \u2014 <code>zip(*zipped)</code> transposes data. If <code>zipped = [(1, 'a'), (2, 'b')]</code>, then <code>list(zip(*zipped))</code> gives <code>[(1, 2), ('a', 'b')]</code>. Reads backwards but super useful.</li> </ul>"},{"location":"python-lists/what-does-zip-do-in-python/#see-also","title":"See also","text":"<ul> <li>How do you iterate over a list in Python?</li> <li>What is list() in Python?</li> <li>External: https://docs.python.org/3/library/functions.html#zip</li> </ul>"},{"location":"python-lists/what-happens-if-you-add-two-lists/","title":"What happens if you add two lists in Python?","text":"<p>In short</p> <p>Adding lists with <code>+</code> glues them together into a brand new list: <code>[1, 2] + [3, 4]</code> becomes <code>[1, 2, 3, 4]</code>. The originals don't change. Under the hood, Python creates a fresh list and copies everything over, which takes time and memory. If you're modifying a list anyway, <code>list1.extend(list2)</code> or <code>list1 += list2</code> is faster\u2014it adds items to the first list without making a copy. Use <code>+</code> when you need both originals intact, use <code>extend()</code> when you're okay changing one in-place.</p> <p>Let me show you the difference:</p> <pre><code># Concatenation creates new list\nlist1 = [1, 2, 3]\nlist2 = [4, 5]\nresult = list1 + list2\nprint(f\"Result: {result}\")\nprint(f\"List1 unchanged: {list1}\")\n\n# In-place concatenation\nlist3 = [10, 20]\nlist3 += [30, 40]\nprint(f\"List3 modified: {list3}\")\n\n# Multiple concatenations\ncombined = [1] + [2] + [3] + [4]\nprint(combined)\n</code></pre> <p>In the code above, <code>list1 + list2</code> creates a new list <code>[1, 2, 3, 4, 5]</code> while leaving both originals untouched. But <code>list3 += [30, 40]</code> modifies <code>list3</code> directly, giving us <code>[10, 20, 30, 40]</code>. The final example chains additions to produce <code>[1, 2, 3, 4]</code>.</p> <p>That <code>+=</code> looks similar to <code>+</code> but behaves differently\u2014it modifies the left side instead of creating a new list.</p>"},{"location":"python-lists/what-happens-if-you-add-two-lists/#gotchas","title":"Gotchas","text":"<ul> <li>Creates a new list \u2014 <code>result = list1 + list2</code> allocates fresh memory. For huge lists, this can be expensive. If you don't need the originals, use <code>extend()</code> to save the allocation.</li> <li>Can't mix types \u2014 <code>[1, 2] + (3, 4)</code> crashes with TypeError. Lists only concatenate with other lists. Convert the tuple first: <code>[1, 2] + list((3, 4))</code>.</li> <li>Chaining is inefficient \u2014 <code>a + b + c + d</code> creates three temporary lists. For better performance, use <code>[*a, *b, *c, *d]</code> (unpacking) or <code>list(itertools.chain(a, b, c, d))</code> if you're doing this a lot.</li> </ul>"},{"location":"python-lists/what-happens-if-you-add-two-lists/#see-also","title":"See also","text":"<ul> <li>How do I add items to a Python list?</li> <li>What does append() mean in Python?</li> <li>External: https://docs.python.org/3/library/stdtypes.html#common-sequence-operations</li> </ul>"},{"location":"python-lists/what-is-a-list-in-simple-terms/","title":"What is a list in simple terms?","text":"<p>In short</p> <p>Imagine a shopping list or a to-do list. That's basically what a Python list is\u2014a container that holds items in order. You write it with square brackets, items separated by commas. Unlike a paper list though, you can easily add new things, cross items off, or change what's written. Python remembers the exact order, and you can grab any item by counting from the top (starting at 0, because programmers like to be difficult). That's it. Simple, flexible, and everywhere in Python code.</p> <p>Here's a quick example to see lists in action:</p> <pre><code># A simple shopping list\nshopping = [\"milk\", \"bread\", \"eggs\"]\n\n# Check what's first\nprint(shopping[0])\n\n# Add an item\nshopping.append(\"butter\")\n\n# See the whole list\nprint(shopping)\n</code></pre> <p>In the code above, <code>shopping[0]</code> gives us \"milk\" (remember, counting starts at 0). Then we append \"butter\" to the end, and the final print shows all four items: <code>['milk', 'bread', 'eggs', 'butter']</code>.</p> <p>The weird part? Counting starts at zero. So <code>shopping[0]</code> gives you \"milk\", not <code>shopping[1]</code>. Everyone stumbles on this at first. You'll get used to it.</p>"},{"location":"python-lists/what-is-a-list-in-simple-terms/#gotchas","title":"Gotchas","text":"<ul> <li>Zero means first \u2014 <code>list[0]</code> is the first item, <code>list[1]</code> is the second. This feels backwards until it clicks. Just remember: Python counts like elevator buttons in some European buildings.</li> <li>Lists remember order \u2014 unlike some other data structures, lists always keep things in the exact sequence you added them. That's the whole point.</li> <li>You can mix types \u2014 throw in numbers, words, even other lists. Python won't complain. But just because you can doesn't mean you should\u2014mixed-type lists can make your code confusing.</li> </ul>"},{"location":"python-lists/what-is-a-list-in-simple-terms/#see-also","title":"See also","text":"<ul> <li>What is a Python list?</li> <li>How do you create a list in Python?</li> <li>External: https://docs.python.org/3/tutorial/introduction.html#lists</li> </ul>"},{"location":"python-lists/what-is-a-python-list/","title":"What is a Python list?","text":"<p>In short</p> <p>Think of a list as your quick storage shelf for keeping multiple things together. It's just square brackets with items inside, separated by commas. The beauty? You can change it anytime\u2014add stuff, remove stuff, rearrange it. Lists remember the order you put things in, and you can grab any item by its position (starting from 0, which trips everyone up at first). They're mutable, ordered, and don't care if you mix types. When you need a flexible collection that grows and shrinks, reach for a list.</p> <p>Here's a quick example showing what you can do with lists:</p> <pre><code># Create a list with mixed types\nmy_list = [1, \"apple\", 3.14, True, [5, 6]]\n\n# Access elements by index\nprint(my_list[0])      # First element\nprint(my_list[-1])     # Last element\n\n# Modify the list\nmy_list.append(\"new\")\nprint(len(my_list))\n</code></pre> <p>In the code above, notice how we can mix numbers, strings, and even other lists. The first <code>print</code> gives us <code>1</code>, the second shows <code>[5, 6]</code> (negative indices count from the end), and after appending, the length becomes <code>6</code>.</p> <p>Here's what catches people: lists are mutable. Pass one to a function and it can change your original list without warning. That's powerful but also a common source of bugs.</p>"},{"location":"python-lists/what-is-a-python-list/#gotchas","title":"Gotchas","text":"<ul> <li>Lists share references \u2014 when you write <code>list2 = list1</code>, you're not copying. Both names point to the same list. Changes to one affect the other. Use <code>list2 = list1.copy()</code> when you need independence.</li> <li>Searching is slow \u2014 checking <code>if item in my_list</code> walks through every element. For big lists, that's painful. If you're doing lots of lookups, a set or dictionary will save you.</li> <li>Zero-based indexing bites beginners \u2014 the first item is <code>my_list[0]</code>, not <code>my_list[1]</code>. It feels weird until it doesn't.</li> </ul>"},{"location":"python-lists/what-is-a-python-list/#see-also","title":"See also","text":"<ul> <li>Python Lists Overview</li> <li>How do you create a list in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html</li> </ul>"},{"location":"python-lists/what-is-list-function-in-python/","title":"What is list() in Python?","text":"<p>In short</p> <p><code>list()</code> is a built-in function that converts things into lists. Call it with no arguments and you get an empty list. Give it something iterable\u2014a string, tuple, range, whatever\u2014and it unpacks all the items into a fresh list. Use <code>list()</code> when converting other data types or when you need explicit type conversion. For creating lists from scratch with known values, literal syntax <code>[1, 2, 3]</code> is clearer and slightly faster than <code>list((1, 2, 3))</code>. Think of <code>list()</code> as the \"turn this into a list\" function, not your go-to creation tool.</p> <p>Here are some practical examples of using <code>list()</code>:</p> <pre><code># Empty list\nempty = list()\n\n# Convert string to list of characters\nchars = list(\"Python\")\n\n# Convert tuple to list\nnumbers = list((1, 2, 3, 4))\n\n# Convert range to list\nsequence = list(range(5))\n\nprint(chars)\nprint(numbers)\nprint(sequence)\n</code></pre> <p>In the code above, <code>list(\"Python\")</code> splits the string into individual characters: <code>['P', 'y', 't', 'h', 'o', 'n']</code>. The tuple <code>(1, 2, 3, 4)</code> becomes a list with the same values. And <code>range(5)</code> expands into <code>[0, 1, 2, 3, 4]</code>.</p> <p>One neat trick: <code>list(existing_list)</code> creates a shallow copy. Handy when you need independence from the original.</p>"},{"location":"python-lists/what-is-list-function-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Brackets are more idiomatic \u2014 writing <code>list()</code> for an empty list works, but <code>[]</code> is what most Python code uses. Save <code>list()</code> for when you're actually converting something.</li> <li>Shallow copy behavior \u2014 <code>list(old_list)</code> copies the list structure but not nested objects. If <code>old_list</code> contains other lists, those inner lists are still shared.</li> <li>Can't pass numbers \u2014 <code>list(5)</code> crashes with TypeError. You probably wanted <code>list(range(5))</code> to get <code>[0, 1, 2, 3, 4]</code>. Easy mistake.</li> </ul>"},{"location":"python-lists/what-is-list-function-in-python/#see-also","title":"See also","text":"<ul> <li>How do you create a list in Python?</li> <li>How do I declare a list in Python?</li> <li>External: https://docs.python.org/3/library/functions.html#func-list</li> </ul>"},{"location":"python-lists/what-is-negative-one-in-list/","title":"What is [-1] in a Python list?","text":"<p>In short</p> <p><code>[-1]</code> grabs the last item in the list. Simple as that. Negative indices count from the end: <code>-1</code> is last, <code>-2</code> is second-to-last, and so on. It's way cleaner than writing <code>list[len(list) - 1]</code> every time you need the last element. Works on any sequence\u2014lists, tuples, strings, whatever. Empty list? You'll get an <code>IndexError</code>, same as with regular indices. But for non-empty lists, <code>[-1]</code> is your quick shortcut to \"give me the last thing.\"</p> <p>Let me show you negative indexing in action:</p> <pre><code># Negative indexing\nnumbers = [10, 20, 30, 40, 50]\n\nprint(numbers[-1])   # Last element\nprint(numbers[-2])   # Second to last\nprint(numbers[-5])   # First element (same as [0])\n\n# Works on strings too\ntext = \"Hello\"\nprint(text[-1])      \n\n# Last element without knowing length\nlast = numbers[-1]\nprint(f\"Last: {last}\")\n</code></pre> <p>In the code above, <code>numbers[-1]</code> gives us <code>50</code>, <code>numbers[-2]</code> gives <code>40</code>, and <code>numbers[-5]</code> reaches all the way back to the first element, <code>10</code>. It even works on strings\u2014<code>text[-1]</code> returns <code>'o'</code>.</p> <p>Notice <code>-5</code> gets you the first element. Count backwards from the end: -1, -2, -3, -4, -5.</p>"},{"location":"python-lists/what-is-negative-one-in-list/#gotchas","title":"Gotchas","text":"<ul> <li>Empty list crashes \u2014 <code>[][-1]</code> raises IndexError. There's no last element to grab. If you're unsure the list has items, check <code>if my_list:</code> first or use slicing: <code>my_list[-1:]</code> returns <code>[]</code> safely.</li> <li>Still out-of-bounds errors \u2014 <code>list[-1000]</code> on a small list crashes. Negative indexing doesn't magically protect you from bad indices, it just changes which direction you're counting.</li> <li>Slicing vs indexing \u2014 in slices, <code>list[:-1]</code> means \"everything except the last element.\" That's different from accessing <code>list[-1]</code>. Takes a moment to internalize.</li> </ul>"},{"location":"python-lists/what-is-negative-one-in-list/#see-also","title":"See also","text":"<ul> <li>How do you access elements in a Python list?</li> <li>How do you slice a list in Python?</li> <li>External: https://docs.python.org/3/tutorial/introduction.html#lists</li> </ul>"},{"location":"python-lists/when-are-lists-preferred-over-dictionaries/","title":"In what situations are lists preferred over dictionaries?","text":"<p>In short</p> <p>Pick lists when position matters more than identity. You're processing items in order? List. Accessing by numeric index like \"give me the 5th item\"? List. You don't have natural keys for lookup? List. They're perfect for sequences (time-series, ordered steps, history), collecting loop results, and when all items are the same type. Lists are simpler and lighter when you don't need the key-value relationship. If you find yourself iterating through all items anyway, a list is probably the right call. Save dicts for when you're looking things up by name, ID, or property.</p> <p>Here's when each structure makes sense:</p> <pre><code># List: ordered processing\ntemperatures = [20, 22, 21, 23, 25]\nfor i, temp in enumerate(temperatures):\n    print(f\"Day {i+1}: {temp}\u00b0C\")\n\nprint(\"---\")\n\n# List: position-based access\nscores = [85, 92, 78]\nprint(f\"First score: {scores[0]}\")\n\n# Dict: lookup by identifier\nstudents = {\"Alice\": 85, \"Bob\": 92, \"Carol\": 78}\nprint(f\"Alice's score: {students['Alice']}\")\n</code></pre> <p>In the code above, the list works perfectly for daily temperatures in sequence. We naturally ask \"what's the temperature on day 3?\" For scores by position, lists win. But when we need Alice's specific score, the dictionary shines\u2014we look it up by name, not position.</p> <p>Notice how lists win when the question is \"what's next?\" but dicts win for \"who scored 85?\"</p>"},{"location":"python-lists/when-are-lists-preferred-over-dictionaries/#gotchas","title":"Gotchas","text":"<ul> <li>Don't fake dict lookups with lists \u2014 if you're writing <code>[x for x in list if x.id == target]</code>, stop. That's a sign you need a dict with IDs as keys.</li> <li>Order matters in dicts too now \u2014 Python 3.7+ dicts maintain insertion order, blurring the lines. But lists still signal \"this is a sequence\" more clearly.</li> <li>JSON conversion \u2014 lists become JSON arrays <code>[]</code>, dicts become objects <code>{}</code>. Match your data structure to your output format.</li> </ul>"},{"location":"python-lists/when-are-lists-preferred-over-dictionaries/#see-also","title":"See also","text":"<ul> <li>When should you use a Python list?</li> <li>Which is better \u2014 list or dictionary in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html</li> </ul>"},{"location":"python-lists/when-to-use-list-comprehension-in-python/","title":"When to use a list comprehension in Python?","text":"<p>In short</p> <p>Use comprehensions for simple, one-line transformations and filtering. They're faster than loops with <code>.append()</code> and more Pythonic. Perfect for mapping (<code>[x*2 for x in nums]</code>), filtering (<code>[x for x in nums if x &gt; 0]</code>), or both together. But here's the rule: if it doesn't fit comfortably on one line or needs a comment to explain, use a regular loop. Nested comprehensions beyond two levels get unreadable fast. Comprehensions are about clarity and conciseness\u2014when they hurt readability, you've gone too far.</p> <p>Here's when comprehensions shine:</p> <pre><code># Good: simple transformation\nnumbers = [1, 2, 3, 4, 5]\nsquares = [x**2 for x in numbers]\nprint(squares)\n\n# Good: filtering\nevens = [x for x in numbers if x % 2 == 0]\nprint(evens)\n\n# Good: both\neven_squares = [x**2 for x in numbers if x % 2 == 0]\nprint(even_squares)\n\n# Bad: too complex (don't do this)\n# result = [f(x) if x &gt; 0 else g(x) if x &lt; 0 else h(x) \n#           for x in data if validate(x) and check(x)]\n</code></pre> <p>In the code above, the first comprehension produces <code>[1, 4, 9, 16, 25]</code>. Filtering gives us <code>[2, 4]</code>. Combining both yields <code>[4, 16]</code>\u2014squares of even numbers only. Simple, readable, fast.</p> <p>That last commented example? If you're tempted to write that, step back and use a loop.</p>"},{"location":"python-lists/when-to-use-list-comprehension-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Readability beats cleverness \u2014 if you need to think hard to understand your own comprehension, it's too complex. Break it down.</li> <li>Memory with large datasets \u2014 comprehensions build the entire list in memory. For millions of items, use generator expressions: <code>(x**2 for x in huge_range)</code>.</li> <li>Side effects are confusing \u2014 don't call functions with side effects in comprehensions like <code>[print(x) for x in items]</code>. It works but reads weird. Use a regular loop.</li> </ul>"},{"location":"python-lists/when-to-use-list-comprehension-in-python/#see-also","title":"See also","text":"<ul> <li>How do you create lists using list comprehension?</li> <li>How do you iterate over a list in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions</li> </ul>"},{"location":"python-lists/when-to-use-python-list/","title":"When should you use a Python list?","text":"<p>In short</p> <p>Use a list when you need ordered items that might change, and you're mainly accessing them by position or looping through everything. Collecting results in a loop? List. Processing items one by one? List. Building a stack (append/pop from end)? List. They're your default for \"I need to store multiple things in order.\" But skip lists if you're constantly checking whether items exist (use a set), looking things up by name or ID (use a dict), or the data shouldn't change (use a tuple). When in doubt, start with a list\u2014it's rarely wrong.</p> <p>Here's when lists shine and when they don't:</p> <pre><code># Good use case: collecting results\nresults = []\nfor i in range(5):\n    results.append(i ** 2)\nprint(results)\n\n# Good: maintaining order\nqueue = [\"first\", \"second\", \"third\"]\ncurrent = queue.pop(0)\nprint(f\"Processing: {current}\")\n\n# Bad pattern: frequent lookups (use set instead)\n# if item in huge_list:  # This is slow!\n\n# Better for lookups\nseen = set()\nseen.add(\"item\")\nprint(\"item\" in seen)  # Fast!\n</code></pre> <p>In the code above, lists work perfectly for collecting those squares: <code>[0, 1, 4, 9, 16]</code>. The queue pattern processes \"first\" and leaves the rest. But that commented-out lookup? On a big list, it's painfully slow. The set version checks membership instantly.</p> <p>See how lists shine for sequential operations but struggle with lookups?</p>"},{"location":"python-lists/when-to-use-python-list/#gotchas","title":"Gotchas","text":"<ul> <li>Not for \"does it contain X\" checks \u2014 running <code>if x in list</code> scans every item. For big collections you search frequently, sets are 100x faster.</li> <li>Not your universal storage \u2014 if you're looking up by ID, name, or key, dictionaries are the answer. Lists are for \"item 0, item 1, item 2\" access patterns.</li> <li>Not for immutable data \u2014 if the data shouldn't change, use a tuple. It signals intent and prevents accidents. Plus tuples can be dict keys; lists can't.</li> </ul>"},{"location":"python-lists/when-to-use-python-list/#see-also","title":"See also","text":"<ul> <li>What is the purpose of using a list in Python?</li> <li>When to use list vs tuple vs dictionary vs set in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html</li> </ul>"},{"location":"python-lists/when-to-use-tuple-instead-of-list/","title":"When would you use a tuple instead of a list?","text":"<p>In short</p> <p>Use tuples when the data shouldn't change\u2014coordinates like (x, y), RGB colors, function returns with multiple values, or database rows. Tuples say \"this structure is fixed\" to anyone reading your code. They can be dict keys and set members (because they're hashable); lists can't. Tuples are a hair faster and lighter on memory, but that's rarely the deciding factor. Choose tuples when immutability is the point\u2014either for safety (preventing accidental changes) or because you need hashability. If you catch yourself wanting to modify items, you probably need a list.</p> <p>Here's when tuples shine:</p> <pre><code># Tuple: fixed structure\npoint = (10, 20)  # x, y coordinates\nrgb = (255, 128, 0)\n\n# Can use as dict key\nlocations = {\n    (0, 0): \"origin\",\n    (10, 20): \"point A\"\n}\nprint(locations[point])\n\n# Tuple unpacking\nx, y = point\nprint(f\"X: {x}, Y: {y}\")\n\n# List: mutable collection\nscores = [85, 92, 78]\nscores.append(90)  # Can modify\nprint(scores)\n</code></pre> <p>In the above code, the tuple <code>(10, 20)</code> works as a dict key, which lists can't do. We unpack it cleanly into <code>x</code> and <code>y</code> variables. Meanwhile, the list accepts new items freely.</p> <p>That dict key usage is huge\u2014you can't do that with lists. Tuples unlock whole patterns.</p>"},{"location":"python-lists/when-to-use-tuple-instead-of-list/#gotchas","title":"Gotchas","text":"<ul> <li>Not fully immutable \u2014 if your tuple contains a list, you can modify that list. The tuple's structure is frozen, but mutable contents inside aren't magically protected.</li> <li>Single-item tuple needs comma \u2014 <code>(1)</code> is just an int in parens. Write <code>(1,)</code> for a one-item tuple. This bites everyone once, then you remember forever.</li> <li>Performance is minor \u2014 tuples are faster, but for small data it's imperceptible. Choose for semantics (\"this shouldn't change\") not micro-optimization.</li> </ul>"},{"location":"python-lists/when-to-use-tuple-instead-of-list/#see-also","title":"See also","text":"<ul> <li>What is the difference between a tuple and a list?</li> <li>When to use list vs tuple vs dictionary vs set in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-lists/which-is-better-list-or-dictionary/","title":"Which is better \u2014 list or dictionary in Python?","text":"<p>In short</p> <p>Neither. They're tools for different jobs. Lists are for ordered sequences you access by position. Dicts are for data you look up by unique keys. It's like asking \"which is better, a screwdriver or a hammer?\" Lists are simpler and lighter for small collections. Dicts give you O(1) lookups instead of O(n). The real question: are you asking \"what's at position 5?\" (list) or \"what's the value for this ID/name?\" (dict). Match your data structure to your access pattern, not abstract notions of \"better.\"</p> <p>Let me show you when each fits:</p> <pre><code># List: position-based, ordered processing\ntasks = [\"Write code\", \"Test code\", \"Deploy\"]\nfor i, task in enumerate(tasks, 1):\n    print(f\"{i}. {task}\")\n\nprint(\"---\")\n\n# Dict: lookup by identifier\nemployees = {\n    \"E001\": \"Alice\",\n    \"E002\": \"Bob\",\n    \"E003\": \"Carol\"\n}\nprint(f\"Employee E002: {employees['E002']}\")\n\n# Combining both is fine\ntask_status = {\"Write code\": \"done\", \"Test code\": \"in progress\"}\nprint(task_status.get(\"Test code\"))\n</code></pre> <p>In the code above, the list naturally fits numbered tasks: \"1. Write code\", \"2. Test code\", \"3. Deploy\". The dict makes employee lookup instant\u2014we ask for \"E002\" and get \"Bob\". And that last line shows you can mix approaches: a dict of task statuses works great.</p> <p>See? Different access patterns, different structures. Use what fits the question you're asking.</p>"},{"location":"python-lists/which-is-better-list-or-dictionary/#gotchas","title":"Gotchas","text":"<ul> <li>Access pattern decides \u2014 if you're iterating with <code>for item in collection:</code>, either works. But if you're doing <code>collection[key]</code> repeatedly, you want a dict.</li> <li>You can combine them \u2014 lists of dicts, dicts of lists\u2014both are perfectly valid when you need both structures. Don't overthink it.</li> <li>Small data doesn't matter \u2014 for &lt;100 items, performance differences are negligible. Pick what reads clearest to you and future maintainers.</li> </ul>"},{"location":"python-lists/which-is-better-list-or-dictionary/#see-also","title":"See also","text":"<ul> <li>Are lists or dictionaries faster in Python?</li> <li>When to use list vs tuple vs dictionary vs set in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html</li> </ul>"},{"location":"python-tuples/","title":"Python Tuples","text":"<p>Everything you need to know about Python tuples - from basics to advanced concepts. 33 in-depth articles covering creation, immutability, unpacking, performance, and comparisons.</p>"},{"location":"python-tuples/#basics-fundamentals","title":"Basics &amp; Fundamentals","text":"<p>Start Here</p> <p>New to Python tuples? These articles cover the foundational concepts.</p> <ul> <li>What is a tuple in Python?</li> <li>What is a tuple for dummies?</li> <li>What is called a tuple in Python?</li> <li>Is a tuple a row or column?</li> <li>Is a tuple an object or a string?</li> </ul>"},{"location":"python-tuples/#creating-writing-tuples","title":"Creating &amp; Writing Tuples","text":"<p>Multiple Ways to Create</p> <p>Learn various methods to create tuples in Python.</p> <ul> <li>How do you write a tuple in Python?</li> <li>Does a tuple use brackets?</li> <li>Can I make an empty tuple?</li> <li>What does the tuple() function do?</li> <li>What are examples of tuples?</li> <li>What is the tuple for 5?</li> <li>Which of the following is a Python tuple?</li> </ul>"},{"location":"python-tuples/#tuple-properties","title":"Tuple Properties","text":"<p>Immutability Matters</p> <p>Understand the key characteristics of tuples.</p> <ul> <li>Are tuples immutable?</li> <li>Can tuples have duplicates?</li> <li>Does tuple keep order in Python?</li> </ul>"},{"location":"python-tuples/#tuple-operations","title":"Tuple Operations","text":"<p>Working with Tuples</p> <p>Common operations and techniques.</p> <ul> <li>Can you unpack a Python tuple?</li> <li>What is slicing in Python?</li> </ul>"},{"location":"python-tuples/#conversion","title":"Conversion","text":"<p>Converting Between Types</p> <p>Transform tuples to other data structures and vice versa.</p> <ul> <li>How do I turn a list into a tuple?</li> <li>Can I convert a tuple to a list in Python?</li> </ul>"},{"location":"python-tuples/#when-to-use-tuples","title":"When to Use Tuples","text":"<p>Use Cases &amp; Best Practices</p> <p>Understand when tuples are the right choice.</p> <ul> <li>When should I use a tuple?</li> <li>Why might you choose to use a tuple instead of a list in Python?</li> <li>What are the practical uses of tuples in Python?</li> </ul>"},{"location":"python-tuples/#performance-advantages","title":"Performance &amp; Advantages","text":"<p>Why Choose Tuples</p> <p>Performance benefits and advantages.</p> <ul> <li>What are the advantages of a tuple over a list?</li> <li>Is tuple or list faster?</li> <li>Is a tuple faster than an array?</li> </ul>"},{"location":"python-tuples/#tuples-vs-other-data-structures","title":"Tuples vs Other Data Structures","text":"<p>Comparison Guide</p> <p>Choose the right data structure for your needs.</p> <ul> <li>What is the difference between a tuple and a list?</li> <li>What are the main differences between list and tuple in Python?</li> <li>What is a tuple vs array in Python?</li> <li>Is a tuple just an array?</li> <li>What cannot have duplicates in Python?</li> <li>What are the disadvantages of list in Python?</li> <li>Is dict mutable in Python?</li> <li>Is Python list ordered or unordered?</li> </ul> <p>:octicons-arrow-left-24: Back to Topics</p>"},{"location":"python-tuples/advantages-of-tuple-over-list/","title":"What are the advantages of a tuple over a list?","text":"<p>In short</p> <p>Tuples are faster to create and iterate, use ~15-20% less memory, and are hashable (usable as dict keys/set members). But the real advantage is semantic: tuples signal \"this data is fixed.\" That prevents bugs from accidental modifications. When you see a tuple in code, you know it won't change\u2014it's a contract. Lists say \"working collection, modify freely.\" Tuples say \"structure is final.\" Use tuples for coordinates, function returns, database rows, or any fixed-size data. The immutability protection is worth more than the minor performance gains.</p> <p>Tuples offer performance, memory, and safety advantages.</p> <p>But the biggest win is communicating intent: this shouldn't change.</p> <p>In the following example, we compare creation speed and use cases:</p> <pre><code>import sys\nimport timeit\n\n# Memory comparison\nt = (1, 2, 3, 4, 5)\nl = [1, 2, 3, 4, 5]\nprint(f\"Tuple size: {sys.getsizeof(t)} bytes\")\nprint(f\"List size: {sys.getsizeof(l)} bytes\")\n\n# Speed comparison (creation)\ntuple_time = timeit.timeit(\"(1, 2, 3, 4, 5)\", number=1000000)\nlist_time = timeit.timeit(\"[1, 2, 3, 4, 5]\", number=1000000)\nprint(f\"\\nTuple creation: {tuple_time:.4f}s\")\nprint(f\"List creation: {list_time:.4f}s\")\n\n# Hashability (main advantage)\ncoords = (10, 20)\nlocations = {coords: \"home\"}  # Works!\nprint(locations[(10, 20)])\n\n# Can't do this with lists\n# coords_list = [10, 20]\n# locations = {coords_list: \"home\"}  # TypeError!\n\n# Safety: tuple protects data\ndef process(data):\n    # If data is a tuple, caller knows we won't modify it\n    return sum(data)\n\nresult = process(t)\nprint(f\"Sum: {result}, original unchanged: {t}\")\n</code></pre> <p>The tuple uses 64 bytes vs list's 88 bytes. Tuple creation is noticeably faster. And the dict key usage is huge\u2014lists just can't do that.</p> <p>That hashability opens up whole patterns that lists can't handle.</p>"},{"location":"python-tuples/advantages-of-tuple-over-list/#gotchas","title":"Gotchas","text":"<ul> <li>Speed advantage is small \u2014 we're talking microseconds unless you're creating millions. Don't choose tuples only for speed.</li> <li>Immutability is shallow \u2014 if your tuple contains lists, those lists can still change. The tuple structure is frozen, not the contents.</li> <li>Function defaults \u2014 using <code>def func(items=())</code> (empty tuple) is safe. Using <code>def func(items=[])</code> (empty list) is a common bug because lists are mutable defaults.</li> </ul>"},{"location":"python-tuples/advantages-of-tuple-over-list/#see-also","title":"See also","text":"<ul> <li>Why might you choose to use a tuple instead of a list in Python?</li> <li>Is tuple or list faster?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/are-tuples-immutable/","title":"Are tuples immutable?","text":"<p>In short</p> <p>Yes. Tuples are completely immutable. Once you create a tuple, you cannot add elements, remove elements, or change what's at any position. No append, no pop, no item assignment. This is the defining feature of tuples\u2014they're frozen sequences. That immutability is what makes them hashable (usable as dict keys and set members), faster than lists, and safer for passing around without fear of modification. If you need to \"change\" a tuple, you create a new one. Immutability is the whole point of tuples.</p> <p>Tuples are immutable, meaning they cannot be modified after creation.</p> <p>Every attempt to change a tuple fails with an error.</p> <p>Here's what immutability means in practice:</p> <pre><code>my_tuple = (1, 2, 3)\n\n# Can't change elements\ntry:\n    my_tuple[0] = 99\nexcept TypeError as e:\n    print(f\"Can't assign: {e}\")\n\n# Can't add elements\ntry:\n    my_tuple.append(4)\nexcept AttributeError as e:\n    print(f\"No append: {e}\")\n\n# Can't remove elements\ntry:\n    my_tuple.remove(2)\nexcept AttributeError as e:\n    print(f\"No remove: {e}\")\n\n# What you CAN do: create a new tuple\nnew_tuple = my_tuple + (4,)\nprint(new_tuple)  # (1, 2, 3, 4)\nprint(my_tuple)  # (1, 2, 3) - original unchanged\n</code></pre> <p>Every modification attempt fails. The only way to get a \"changed\" tuple is to create a new one using concatenation or other operations.</p> <p>That immutability is why tuples are used for fixed data like coordinates, RGB values, or database records.</p>"},{"location":"python-tuples/are-tuples-immutable/#gotchas","title":"Gotchas","text":"<ul> <li>Immutability is shallow \u2014 if your tuple contains a list, that list can still be modified: <code>t = ([1, 2], 3)</code> allows <code>t[0].append(3)</code>. The tuple's structure is frozen, but mutable contents aren't.</li> <li>Tuples are hashable \u2014 because they're immutable, you can use them as dict keys and add them to sets. Lists can't do this.</li> <li>Memory efficiency \u2014 immutable objects can be optimized by Python. Tuples use less memory than equivalent lists.</li> </ul>"},{"location":"python-tuples/are-tuples-immutable/#see-also","title":"See also","text":"<ul> <li>What is a tuple in Python?</li> <li>What are the advantages of a tuple over a list?</li> <li>External: https://docs.python.org/3/glossary.html#term-immutable</li> </ul>"},{"location":"python-tuples/can-i-make-an-empty-tuple/","title":"Can I make an empty tuple?","text":"<p>In short</p> <p>Yes. Use <code>empty_tuple = ()</code> or <code>empty_tuple = tuple()</code>. Both create an empty tuple with length 0. Empty tuples are useful as default values, placeholders, or initial values before building up data. Unlike empty lists (which are mutable and can cause default argument bugs), empty tuples are safe as defaults. Note: empty parentheses <code>()</code> make an empty tuple, but empty curly braces <code>{}</code> make an empty dict, not an empty set. For an empty set, use <code>set()</code>.</p> <p>Creating an empty tuple is straightforward and useful.</p> <p>Just use empty parentheses or call the <code>tuple()</code> constructor.</p> <p>In the following example, we create and work with empty tuples:</p> <pre><code># Two ways to create empty tuple\nempty1 = ()\nempty2 = tuple()\n\nprint(empty1)  # ()\nprint(empty2)  # ()\nprint(type(empty1))  # &lt;class 'tuple'&gt;\nprint(len(empty1))  # 0\n\n# They're equal\nprint(empty1 == empty2)  # True\n\n# Safe as function default\ndef process_data(items=()):\n    if not items:\n        return \"No data\"\n    return sum(items)\n\nprint(process_data())  # \"No data\"\nprint(process_data((1, 2, 3)))  # 6\n\n# Compare with empty list (mutable, dangerous as default)\ndef bad_function(items=[]):  # DON'T do this!\n    items.append(\"surprise\")\n    return items\n\nprint(bad_function())  # ['surprise']\nprint(bad_function())  # ['surprise', 'surprise'] - Oops!\n\n# Empty tuple is immutable, so safe\ndef good_function(items=()):\n    return tuple(list(items) + [\"added\"])\n\nprint(good_function())  # ('added',)\nprint(good_function())  # ('added',) - Always fresh\n\n# Building up from empty\nresult = ()\nfor i in range(3):\n    result = result + (i,)  # Inefficient but works\nprint(result)  # (0, 1, 2)\n</code></pre> <p>Both <code>()</code> and <code>tuple()</code> create the same empty tuple. The empty tuple is safe as a default because it's immutable\u2014every call gets the same frozen empty tuple, which can't accidentally accumulate state.</p> <p>Empty tuples are less common than empty lists, but they have their uses.</p>"},{"location":"python-tuples/can-i-make-an-empty-tuple/#gotchas","title":"Gotchas","text":"<ul> <li>Empty dict, not empty set \u2014 <code>{}</code> creates an empty dict. For an empty set, use <code>set()</code>. Empty tuple is <code>()</code>.</li> <li>Building tuples is slow \u2014 adding to tuples with <code>result = result + (new_item,)</code> creates a new tuple each time. For building, use lists and convert: <code>tuple(my_list)</code>.</li> <li>Empty tuple is falsy \u2014 <code>if my_tuple:</code> returns False for empty tuples. Use <code>if len(my_tuple) &gt; 0:</code> if you need explicit checks.</li> </ul>"},{"location":"python-tuples/can-i-make-an-empty-tuple/#see-also","title":"See also","text":"<ul> <li>How do you write a tuple in Python?</li> <li>What is the tuple for 5?</li> <li>External: https://docs.python.org/3/library/functions.html#func-tuple</li> </ul>"},{"location":"python-tuples/can-tuples-have-duplicates/","title":"Can tuples have duplicates?","text":"<p>In short</p> <p>Yes, absolutely. Tuples don't care about uniqueness\u2014they'll happily hold the same value multiple times. <code>(1, 2, 2, 3, 2)</code> is perfectly valid. That's different from sets, which automatically remove duplicates. Tuples preserve exactly what you put in, in the order you put it. This is useful when you're representing sequences where repetition matters: dice rolls, color histograms, database rows with repeated categories. If you need uniqueness, convert to a set. But tuples themselves? They allow and maintain duplicates just fine.</p> <p>Tuples allow duplicate values without complaint.</p> <p>Unlike sets (which enforce uniqueness), tuples keep every element you give them, even if some appear multiple times.</p> <p>In the following example, we create tuples with duplicates and see how Python handles them:</p> <pre><code># Tuples with duplicates\nnumbers = (1, 2, 2, 3, 2, 4)\nprint(numbers)  # (1, 2, 2, 3, 2, 4)\nprint(numbers.count(2))  # 3\n\n# Compare with a set (removes duplicates)\nunique_numbers = set(numbers)\nprint(unique_numbers)  # {1, 2, 3, 4}\n\n# Use case: color histogram\ncolors = ('red', 'blue', 'red', 'green', 'red')\nprint(f\"Red appears {colors.count('red')} times\")\n</code></pre> <p>The tuple preserves all three <code>2</code>s. The set collapses them into one. Converting to a set shows <code>{1, 2, 3, 4}</code> with duplicates gone.</p> <p>That <code>.count()</code> method is handy when you need to know how many times something appears.</p>"},{"location":"python-tuples/can-tuples-have-duplicates/#gotchas","title":"Gotchas","text":"<ul> <li>Duplicates affect length \u2014 <code>len((1, 1, 1))</code> is 3, not 1. Every element counts, even if they're the same value.</li> <li>Sets vs tuples \u2014 if you see duplicates and don't want them, use a set. Tuples won't automatically deduplicate for you.</li> <li>Tuple as dict key \u2014 you can use <code>(1, 2, 2)</code> as a dict key. But if you convert it to a list first, you can't (lists aren't hashable). Immutability matters.</li> </ul>"},{"location":"python-tuples/can-tuples-have-duplicates/#see-also","title":"See also","text":"<ul> <li>What cannot have duplicates in Python?</li> <li>Does tuple keep order in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/can-you-unpack-a-python-tuple/","title":"Can you unpack a Python tuple?","text":"<p>In short</p> <p>Yes, and it's one of Python's most elegant features. Write <code>x, y, z = (1, 2, 3)</code> and each variable gets its value. Works with any iterable, not just tuples. Common uses: function returns <code>name, age = get_user()</code>, swapping <code>a, b = b, a</code>, ignoring values with <code>_</code>, or partial unpacking with <code>*rest</code>. Number of variables must match tuple length (or use <code>*</code> for variable-length). Unpacking makes code cleaner than indexing: compare <code>x, y = point</code> vs <code>x = point[0]; y = point[1]</code>. It's the Pythonic way.</p> <p>Tuple unpacking assigns elements to multiple variables in one line.</p> <p>It's syntactic sugar that makes code more readable.</p> <p>In the following example, we see unpacking in action:</p> <pre><code># Basic unpacking\ncoordinates = (10, 20)\nx, y = coordinates\nprint(f\"x={x}, y={y}\")\n\n# Works without parentheses\na, b, c = 1, 2, 3\nprint(f\"a={a}, b={b}, c={c}\")\n\n# Swapping variables (classic use)\nx, y = 5, 10\nx, y = y, x  # Elegant swap\nprint(f\"After swap: x={x}, y={y}\")\n\n# Function returns\ndef get_user():\n    return (\"Alice\", 30, \"alice@example.com\")\n\nname, age, email = get_user()\nprint(f\"{name}, {age}, {email}\")\n\n# Ignoring values with underscore\nfirst, _, third = (1, 2, 3)\nprint(f\"first={first}, third={third}\")\n\n# Extended unpacking with * (Python 3+)\nfirst, *middle, last = (1, 2, 3, 4, 5)\nprint(f\"first={first}, middle={middle}, last={last}\")\n\n# Must match length (or use *)\ntry:\n    a, b = (1, 2, 3)  # Too many values\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre> <p>The basic form <code>x, y = (10, 20)</code> is clean and obvious. The swap <code>a, b = b, a</code> is Python magic. Extended unpacking with <code>*middle</code> captures variable-length sequences.</p> <p>Unpacking is why tuples are perfect for function returns\u2014you can destructure them immediately.</p>"},{"location":"python-tuples/can-you-unpack-a-python-tuple/#gotchas","title":"Gotchas","text":"<ul> <li>Length must match \u2014 <code>a, b = (1, 2, 3)</code> raises <code>ValueError: too many values to unpack</code>. Use <code>*</code> for variable-length.</li> <li>Works on any iterable \u2014 you can unpack lists, strings, ranges: <code>a, b, c = \"abc\"</code> works. Not tuple-specific.</li> <li>Nested unpacking \u2014 <code>(a, b), c = ((1, 2), 3)</code> works but gets hard to read. Keep it simple.</li> </ul>"},{"location":"python-tuples/can-you-unpack-a-python-tuple/#see-also","title":"See also","text":"<ul> <li>How do I turn a list into a tuple?</li> <li>What are the practical uses of tuples in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/convert-tuple-to-list/","title":"Can I convert a tuple to a list in Python?","text":"<p>In short</p> <p>Yes. Use <code>my_list = list(my_tuple)</code>. This creates a new mutable list with the same elements. The original tuple stays unchanged\u2014they're separate objects. Why convert? When you need to add, remove, or modify elements. Lists have <code>.append()</code>, <code>.remove()</code>, <code>.sort()</code>, etc. Tuples don't. Convert when you need mutability. Common pattern: receive a tuple, convert to list for processing, optionally convert back to tuple for return. The conversion is fast for small sequences, but remember: it's a shallow copy. If the tuple contains mutable objects, those are shared.</p> <p>Call <code>list()</code> with your tuple as the argument.</p> <p>Simple, fast, and creates an independent mutable copy.</p> <p>In the following example, we convert tuples to lists and see how they behave:</p> <pre><code># Basic conversion\nmy_tuple = (1, 2, 3, 4, 5)\nmy_list = list(my_tuple)\n\nprint(my_tuple)  # (1, 2, 3, 4, 5)\nprint(my_list)   # [1, 2, 3, 4, 5]\nprint(type(my_list))  # &lt;class 'list'&gt;\n\n# Now you can modify the list\nmy_list.append(6)\nmy_list.remove(2)\nmy_list[0] = 99\n\nprint(my_list)   # [99, 1, 3, 4, 5, 6]\nprint(my_tuple)  # (1, 2, 3, 4, 5) - unchanged\n\n# Common pattern: process and convert back\ndef process_data(data_tuple):\n    # Convert to list for modification\n    data_list = list(data_tuple)\n\n    # Process\n    data_list.sort()\n    data_list.append(max(data_list) + 1)\n\n    # Convert back to tuple\n    return tuple(data_list)\n\nresult = process_data((5, 2, 8, 1))\nprint(result)  # (1, 2, 5, 8, 9)\n\n# Empty tuple converts to empty list\nempty_list = list(())\nprint(empty_list)  # []\n</code></pre> <p>The list() constructor creates <code>[1, 2, 3, 4, 5]</code> from <code>(1, 2, 3, 4, 5)</code>. Modifications to the list don't affect the tuple\u2014they're separate objects.</p> <p>That independence is key: converting gives you a mutable workspace.</p>"},{"location":"python-tuples/convert-tuple-to-list/#gotchas","title":"Gotchas","text":"<ul> <li>Shallow copy \u2014 <code>list(my_tuple)</code> copies the tuple structure, but if elements are mutable (like nested lists), those are shared between tuple and list.</li> <li>Performance \u2014 for huge tuples (millions of elements), conversion takes time and memory. Don't convert unnecessarily in tight loops.</li> <li>Why not just use list initially? \u2014 sometimes you receive tuples from libraries, database drivers, or function returns. You don't choose the type, so you convert.</li> </ul>"},{"location":"python-tuples/convert-tuple-to-list/#see-also","title":"See also","text":"<ul> <li>How do I turn a list into a tuple?</li> <li>What does the tuple() function do?</li> <li>External: https://docs.python.org/3/library/functions.html#func-list</li> </ul>"},{"location":"python-tuples/difference-between-tuple-and-list/","title":"What is the difference between a tuple and a list?","text":"<p>In short</p> <p>The big one: tuples can't be changed (immutable), lists can (mutable). Tuples use parentheses <code>(1, 2, 3)</code>, lists use brackets <code>[1, 2, 3]</code>. Because tuples are immutable, they're hashable\u2014you can use them as dict keys and set members. Lists can't do that. Tuples are slightly faster and use less memory. Lists have more methods (append, remove, etc.). Use tuples for fixed data like coordinates or function returns. Use lists for collections you'll modify. Tuples signal \"this structure won't change.\" Lists signal \"this is a working collection.\"</p> <p>Mutability is the core difference\u2014everything else flows from that.</p> <p>Tuples are frozen. Lists are flexible.</p> <p>In the following example, we compare their behavior side-by-side:</p> <pre><code># Creation syntax\nmy_tuple = (1, 2, 3)\nmy_list = [1, 2, 3]\n\n# Modification\nmy_list[0] = 99  # Works fine\nprint(my_list)  # [99, 2, 3]\n\ntry:\n    my_tuple[0] = 99  # Fails\nexcept TypeError as e:\n    print(f\"Tuple error: {e}\")\n\n# Adding elements\nmy_list.append(4)\nprint(my_list)  # [99, 2, 3, 4]\n\n# Tuples can't append (no method exists)\nprint(dir(my_tuple))  # No append, remove, etc.\n\n# Hashability\nprint(hash(my_tuple))  # Works - tuples are hashable\ntry:\n    print(hash(my_list))  # Fails\nexcept TypeError as e:\n    print(f\"List error: {e}\")\n\n# Dict keys\nmy_dict = {my_tuple: \"value\"}  # Works\n# my_dict = {my_list: \"value\"}  # Would fail\n</code></pre> <p>The list cheerfully modifies. The tuple refuses. The list can't be hashed. The tuple can be a dict key.</p> <p>Those constraints define when you use each.</p>"},{"location":"python-tuples/difference-between-tuple-and-list/#gotchas","title":"Gotchas","text":"<ul> <li>Conversion is easy \u2014 <code>list(my_tuple)</code> and <code>tuple(my_list)</code> convert between them. Useful when you need mutability or immutability temporarily.</li> <li>Performance difference is minor \u2014 for small collections (&lt;1000 items), the speed difference is negligible. Choose for semantics, not micro-optimization.</li> <li>Both keep order \u2014 lists and tuples both maintain insertion order. Sets don't guarantee order (though modern Python preserves it).</li> </ul>"},{"location":"python-tuples/difference-between-tuple-and-list/#see-also","title":"See also","text":"<ul> <li>What are the main differences between list and tuple in Python?</li> <li>What are the advantages of a tuple over a list?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html</li> </ul>"},{"location":"python-tuples/disadvantages-of-list-in-python/","title":"What are the disadvantages of list in Python?","text":"<p>In short</p> <p>Lists are slower for membership tests (<code>x in list</code> is O(n)), use more memory than tuples due to over-allocation for growth, and can't be dict keys or set members because they're not hashable. Their mutability is both strength and weakness\u2014it enables bugs when lists get modified unexpectedly, especially when passed to functions or used as default arguments. For large datasets, lists are slower than NumPy arrays for numeric ops. And inserting/deleting from the middle is slow (O(n)). Choose sets for lookups, tuples for immutability, deques for queues, or NumPy for math.</p> <p>Lists trade versatility for optimization\u2014they're general-purpose, not specialized.</p> <p>Here are the key limitations:</p> <p>In the following example, we demonstrate list performance issues:</p> <pre><code>import sys\n\n# Memory overhead\nmy_list = [1, 2, 3]\nmy_tuple = (1, 2, 3)\nprint(f\"List: {sys.getsizeof(my_list)} bytes\")\nprint(f\"Tuple: {sys.getsizeof(my_tuple)} bytes\")\n\n# Slow membership testing\nlarge_list = list(range(10000))\n# This checks every element until found\nresult = 9999 in large_list  # Slow!\n\n# Compare with set\nlarge_set = set(range(10000))\nresult = 9999 in large_set  # Fast! O(1)\n\n# Can't be dict key\ncoords = [10, 20]\ntry:\n    cache = {coords: \"value\"}\nexcept TypeError as e:\n    print(f\"Dict key error: {e}\")\n\n# Mutability gotcha\ndef add_item(items=[]):  # DANGER!\n    items.append(\"new\")\n    return items\n\nprint(add_item())  # ['new']\nprint(add_item())  # ['new', 'new'] - Oops!\n</code></pre> <p>The list uses 88 bytes vs tuple's 64. The membership test walks through thousands of items. And that default argument bug is infamous\u2014the empty list is created once and reused.</p> <p>These aren't bugs in lists\u2014they're trade-offs for flexibility.</p>"},{"location":"python-tuples/disadvantages-of-list-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Membership testing \u2014 if you're doing <code>if x in my_list</code> repeatedly, convert to a set. That O(n) adds up fast.</li> <li>Mutable defaults \u2014 never use <code>def func(items=[])</code>. Use <code>def func(items=None): if items is None: items = []</code>.</li> <li>Shared references \u2014 <code>list2 = list1</code> doesn't copy. Both names point to the same list. Use <code>list2 = list1.copy()</code> for independence.</li> </ul>"},{"location":"python-tuples/disadvantages-of-list-in-python/#see-also","title":"See also","text":"<ul> <li>What are the advantages of a tuple over a list?</li> <li>What is the difference between a tuple and a list?</li> <li>External: https://wiki.python.org/moin/TimeComplexity</li> </ul>"},{"location":"python-tuples/does-tuple-keep-order-in-python/","title":"Does tuple keep order in Python?","text":"<p>In short</p> <p>Yes, absolutely. Tuples are ordered sequences\u2014they remember exactly the sequence you created them in. <code>(3, 1, 2)</code> stays <code>(3, 1, 2)</code> forever. You can access elements by position (<code>my_tuple[0]</code>), slice them (<code>my_tuple[1:3]</code>), and iterate in predictable order. This is a defining feature of tuples, just like lists. Sets are the unordered collection\u2014they don't guarantee sequence. If order matters (and it usually does), tuples and lists both maintain it. Tuples just freeze that order permanently.</p> <p>Tuples are fully ordered collections.</p> <p>They maintain the exact insertion order and support positional access.</p> <p>In the following example, we demonstrate tuple ordering:</p> <pre><code># Order is preserved\nmy_tuple = (5, 2, 8, 1, 9)\nprint(my_tuple)  # (5, 2, 8, 1, 9) - exactly as created\n\n# Access by position\nprint(f\"First: {my_tuple[0]}\")   # 5\nprint(f\"Second: {my_tuple[1]}\")  # 2\nprint(f\"Last: {my_tuple[-1]}\")   # 9\n\n# Slicing respects order\nprint(my_tuple[1:4])  # (2, 8, 1)\n\n# Iteration goes in order\nfor i, value in enumerate(my_tuple):\n    print(f\"Position {i}: {value}\")\n\n# Compare with set (unordered)\nmy_set = {5, 2, 8, 1, 9}\nprint(f\"\\nSet: {my_set}\")  # Order may vary\n# Can't do my_set[0] - no indexing in sets\n\n# Tuples with same elements in different order are NOT equal\ntuple1 = (1, 2, 3)\ntuple2 = (3, 2, 1)\nprint(f\"\\n{tuple1} == {tuple2}: {tuple1 == tuple2}\")  # False\n</code></pre> <p>The tuple keeps <code>(5, 2, 8, 1, 9)</code> in that exact order. Indexing works. Slicing works. Order is guaranteed.</p> <p>The set may display elements in any order (though modern Python often preserves insertion order in practice).</p>"},{"location":"python-tuples/does-tuple-keep-order-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Immutability doesn't mean unordered \u2014 tuples are both immutable AND ordered. Don't confuse the two properties.</li> <li>Sorting creates new tuple \u2014 you can't do <code>my_tuple.sort()</code> (no method). Use <code>sorted(my_tuple)</code> which returns a list, then <code>tuple(sorted(my_tuple))</code> for a sorted tuple.</li> <li>Order equality matters \u2014 <code>(1, 2)</code> and <code>(2, 1)</code> are different tuples. Order is part of the identity.</li> </ul>"},{"location":"python-tuples/does-tuple-keep-order-in-python/#see-also","title":"See also","text":"<ul> <li>Are tuples immutable?</li> <li>Is Python list ordered or unordered?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/does-tuple-use-brackets/","title":"Does a tuple use brackets?","text":"<p>In short</p> <p>Tuples use parentheses <code>()</code> for creation, not brackets. Lists use square brackets <code>[]</code>. Dictionaries use curly braces <code>{}</code>. But here's the confusing part: you access tuple elements WITH brackets: <code>my_tuple[0]</code>. So tuples are created with <code>()</code> but accessed with <code>[]</code>. That bracket notation is for indexing\u2014it works on any sequence (tuples, lists, strings). Creation syntax differs, but element access is consistent across all sequences. Remember: <code>(1, 2, 3)</code> creates a tuple, <code>my_tuple[1]</code> accesses its second element.</p> <p>Tuples use parentheses for creation, but brackets for element access.</p> <p>This can be confusing at first, but it's consistent with how Python handles all sequences.</p> <p>In the following example, we see both syntaxes in use:</p> <pre><code># Creating structures - different brackets\nmy_tuple = (1, 2, 3)    # Parentheses for tuples\nmy_list = [1, 2, 3]     # Square brackets for lists\nmy_dict = {\"a\": 1}      # Curly braces for dicts\nmy_set = {1, 2, 3}      # Curly braces for sets\n\n# Accessing elements - SAME brackets for sequences\nprint(my_tuple[0])  # 1 - brackets for access\nprint(my_list[0])   # 1 - brackets for access\nprint(\"hello\"[0])   # 'h' - even strings use brackets\n\n# Slicing also uses brackets\nprint(my_tuple[1:3])  # (2, 3)\nprint(my_list[1:3])   # [2, 3]\n\n# This is NOT a tuple (just parentheses for grouping)\nnot_tuple = (5)\nprint(type(not_tuple))  # &lt;class 'int'&gt;\n\n# This IS a tuple (comma makes it)\nis_tuple = (5,)\nprint(type(is_tuple))  # &lt;class 'tuple'&gt;\nprint(is_tuple[0])  # 5 - access with brackets\n</code></pre> <p>Parentheses create tuples (with commas). Brackets access elements. Same pattern for lists, tuples, strings\u2014all sequences use <code>[]</code> for indexing.</p> <p>The brackets are for the indexing operation, not the data type definition.</p>"},{"location":"python-tuples/does-tuple-use-brackets/#gotchas","title":"Gotchas","text":"<ul> <li>Parentheses for grouping \u2014 <code>(5)</code> is just the number 5 in parens. <code>(5,)</code> is a tuple. The comma matters more than the parentheses.</li> <li>Tuple unpacking uses no brackets \u2014 <code>a, b, c = my_tuple</code> doesn't need brackets on the left side.</li> <li>Bracket means \"get item\" \u2014 whether it's <code>my_tuple[0]</code>, <code>my_list[0]</code>, or <code>my_dict[\"key\"]</code>, brackets mean \"give me this element.\"</li> </ul>"},{"location":"python-tuples/does-tuple-use-brackets/#see-also","title":"See also","text":"<ul> <li>How do you write a tuple in Python?</li> <li>What is the tuple for 5?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/example-of-a-tuple/","title":"What is an example of a tuple?","text":"<p>In short</p> <p>Common tuple examples: coordinates <code>(x, y, z)</code>, RGB colors <code>(255, 128, 0)</code>, date/time values <code>(2025, 10, 7)</code>, function returns <code>(status, message)</code>, database rows <code>(id, name, email)</code>, constant configurations <code>(HOST, PORT, PROTOCOL)</code>. Any time you have related values that form a fixed structure, that's tuple territory. They're perfect for representing records, points in space, or grouped values that travel together. The pattern: if the number of elements is fixed and each position has meaning, use a tuple.</p> <p>Here are real-world tuple examples you'll encounter:</p> <pre><code># 1. Coordinates (2D, 3D)\npoint_2d = (10, 20)\npoint_3d = (10, 20, 30)\nx, y = point_2d\n\n# 2. RGB/RGBA colors\nred = (255, 0, 0)\nsemi_transparent_blue = (0, 0, 255, 128)\n\n# 3. Date components\ndate = (2025, 10, 7)  # year, month, day\nyear, month, day = date\n\n# 4. Function returns\ndef divide_with_remainder(a, b):\n    return (a // b, a % b)\n\nquotient, remainder = divide_with_remainder(17, 5)\nprint(f\"17 \u00f7 5 = {quotient} remainder {remainder}\")\n\n# 5. Database-style records\nemployee = (\"E001\", \"Alice Johnson\", 30, \"Engineering\")\nemp_id, name, age, dept = employee\n\n# 6. Configuration tuples\nDATABASE = (\"localhost\", 5432, \"myapp_db\")\nhost, port, dbname = DATABASE\n\n# 7. Geographic coordinates\nlocation = (40.7128, -74.0060)  # NYC latitude, longitude\n\n# 8. Version numbers\nversion = (2, 5, 1)  # major, minor, patch\n</code></pre> <p>Each example shows fixed-size, heterogeneous (or homogeneous) data where the structure has meaning.</p> <p>Tuples shine when each position represents something specific.</p>"},{"location":"python-tuples/example-of-a-tuple/#gotchas","title":"Gotchas","text":"<ul> <li>Don't overuse tuples \u2014 if you have more than 5 elements, consider a class or <code>namedtuple</code> for clarity. <code>employee[3]</code> is less clear than <code>employee.dept</code>.</li> <li>Tuples aren't always better \u2014 for a list of coordinates, use a list of tuples: <code>[(10, 20), (30, 40)]</code>. The outer collection is dynamic, the inner structures are fixed.</li> <li>Type hints help \u2014 <code>Tuple[int, int]</code> (from <code>typing</code>) documents that a function returns exactly two ints.</li> </ul>"},{"location":"python-tuples/example-of-a-tuple/#see-also","title":"See also","text":"<ul> <li>What are the practical uses of tuples in Python?</li> <li>How do you write a tuple in Python?</li> <li>External: https://docs.python.org/3/library/collections.html#collections.namedtuple</li> </ul>"},{"location":"python-tuples/how-to-turn-list-into-tuple/","title":"How do I turn a list into a tuple?","text":"<p>In short</p> <p>Just wrap it in <code>tuple()</code>: <code>my_tuple = tuple(my_list)</code>. Done. This creates an immutable copy with the same elements in the same order. The original list stays unchanged. Why convert? To use as a dict key, pass to a function that expects immutability, or freeze data you don't want modified. Conversion is fast for small lists, but remember: if your list contains mutable objects (like other lists), those inner objects stay mutable. The tuple structure is frozen, but nested mutables aren't magically protected.</p> <p>Call <code>tuple()</code> with your list as the argument.</p> <p>That's it. Python creates a new tuple with the same elements.</p> <p>In the following example, we convert lists to tuples and see how they behave:</p> <pre><code># Basic conversion\nmy_list = [1, 2, 3, 4]\nmy_tuple = tuple(my_list)\nprint(my_tuple)  # (1, 2, 3, 4)\nprint(type(my_tuple))  # &lt;class 'tuple'&gt;\n\n# Original list unchanged\nmy_list.append(5)\nprint(my_list)  # [1, 2, 3, 4, 5]\nprint(my_tuple)  # (1, 2, 3, 4) - unchanged\n\n# Use case: dictionary key\ncoordinates_list = [10, 20]\n# Can't use list as dict key\n# my_dict = {coordinates_list: \"point A\"}  # TypeError\n\n# But tuple works\ncoordinates_tuple = tuple(coordinates_list)\nmy_dict = {coordinates_tuple: \"point A\"}\nprint(my_dict[(10, 20)])  # \"point A\"\n</code></pre> <p>The conversion creates <code>(1, 2, 3, 4)</code> from <code>[1, 2, 3, 4]</code>. Changes to the list don't affect the tuple\u2014they're separate objects. The dict key example shows why you'd convert: lists can't be keys, but tuples can.</p> <p>That's the main reason to convert: unlock hashability.</p>"},{"location":"python-tuples/how-to-turn-list-into-tuple/#gotchas","title":"Gotchas","text":"<ul> <li>Shallow copy \u2014 <code>tuple(my_list)</code> copies the list structure, but if the list contains other lists, those inner lists are still mutable and shared.</li> <li>Empty and single-element \u2014 <code>tuple([])</code> gives <code>()</code>. <code>tuple([5])</code> gives <code>(5,)</code> with the trailing comma automatically handled.</li> <li>Performance \u2014 converting huge lists (millions of elements) takes time and memory. If you're doing it in a hot loop, reconsider your design.</li> </ul>"},{"location":"python-tuples/how-to-turn-list-into-tuple/#see-also","title":"See also","text":"<ul> <li>Can I convert a tuple to a list in Python?</li> <li>What is the difference between a tuple and a list?</li> <li>External: https://docs.python.org/3/library/functions.html#func-tuple</li> </ul>"},{"location":"python-tuples/how-to-write-a-tuple-in-python/","title":"How do you write a tuple in Python?","text":"<p>In short</p> <p>Write tuples with parentheses and commas: <code>(1, 2, 3)</code>. The comma is what creates the tuple\u2014parentheses just make it clear. You can omit them: <code>x = 1, 2, 3</code> is valid but less readable. For single-element tuples, the trailing comma is mandatory: <code>(5,)</code> not <code>(5)</code>. Empty tuples need parentheses: <code>()</code>. Tuples can hold any types, mixed or uniform: <code>(1, \"text\", 3.14, [1, 2])</code> works fine. The syntax is simple, but that single-element comma trips everyone up at least once.</p> <p>The basic syntax is parentheses with commas separating values.</p> <p>But there are several valid forms and important edge cases.</p> <p>Here's how to write tuples correctly:</p> <pre><code># Standard tuple\nmy_tuple = (1, 2, 3)\nprint(my_tuple)  # (1, 2, 3)\n\n# Without parentheses (valid, but less clear)\nalso_tuple = 1, 2, 3\nprint(also_tuple)  # (1, 2, 3)\nprint(type(also_tuple))  # &lt;class 'tuple'&gt;\n\n# Single-element tuple (comma is REQUIRED)\nsingle = (5,)\nprint(single)  # (5,)\nprint(len(single))  # 1\n\n# Without comma, it's just the value\nnot_tuple = (5)\nprint(type(not_tuple))  # &lt;class 'int'&gt;\n\n# Empty tuple\nempty = ()\nprint(empty)  # ()\n\n# Mixed types (perfectly fine)\nmixed = (1, \"hello\", 3.14, [1, 2], {\"key\": \"value\"})\nprint(mixed)\n\n# Nested tuples\nnested = ((1, 2), (3, 4), (5, 6))\nprint(nested)\n\n# Trailing comma in multi-element (optional, but helps with diffs)\nwith_trailing = (\n    1,\n    2,\n    3,\n)\nprint(with_trailing)  # (1, 2, 3)\n</code></pre> <p>The standard form <code>(1, 2, 3)</code> is clearest. The single-element <code>(5,)</code> is the gotcha. The comma-only form <code>1, 2, 3</code> works but is less obvious.</p> <p>Stick to parentheses for clarity, but know the comma is what matters.</p>"},{"location":"python-tuples/how-to-write-a-tuple-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Single-element trap \u2014 <code>(x)</code> is just <code>x</code>. Write <code>(x,)</code>. This is the #1 tuple gotcha. Test with <code>len()</code> if unsure.</li> <li>Tuple unpacking \u2014 <code>a, b, c = (1, 2, 3)</code> works without parens on the right: <code>a, b, c = 1, 2, 3</code> is equivalent.</li> <li>Generator vs tuple \u2014 <code>(x for x in range(5))</code> is a generator expression, not a tuple. Use <code>tuple(x for x in range(5))</code> to get a tuple.</li> </ul>"},{"location":"python-tuples/how-to-write-a-tuple-in-python/#see-also","title":"See also","text":"<ul> <li>What is the tuple for 5?</li> <li>Can I make an empty tuple?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/is-a-tuple-a-row-or-column/","title":"Is a tuple a row or column?","text":"<p>In short</p> <p>Neither\u2014a tuple is just an ordered sequence. But contextually, tuples often represent rows in databases or CSV files. When you fetch a database record, each row comes back as a tuple: <code>(id, name, email)</code>. That's why people associate tuples with rows. Columns would be lists of values for one field across many rows. So if you're thinking databases: tuple = one row of data. If you're thinking matrices: tuples can be rows or column vectors depending on use. But fundamentally, a tuple is neither\u2014it's a general-purpose immutable sequence that you can use however you want.</p> <p>Tuples are conceptually neutral, but in practice they often represent rows of data.</p> <p>When you work with databases or CSV files, each record (one row) typically comes as a tuple.</p> <p>In the following example, we see how tuples represent database rows:</p> <pre><code># Database-style rows as tuples\nemployee1 = (101, \"Alice\", \"Engineering\")\nemployee2 = (102, \"Bob\", \"Sales\")\nemployee3 = (103, \"Carol\", \"Engineering\")\n\n# All employees (list of tuples = table)\nemployees = [employee1, employee2, employee3]\n\n# Process each row\nfor emp_id, name, dept in employees:\n    print(f\"{name} (ID: {emp_id}) works in {dept}\")\n\n# Column would be extracting one field across all rows\nnames = [emp[1] for emp in employees]\nprint(f\"Names column: {names}\")\n</code></pre> <p>Each tuple is a row with three fields. When we loop, we unpack each row naturally. Extracting all names gives us a column-like view.</p> <p>In data science with NumPy or Pandas, row vs column matters more. But for plain Python? Tuples are just sequences.</p>"},{"location":"python-tuples/is-a-tuple-a-row-or-column/#gotchas","title":"Gotchas","text":"<ul> <li>Database convention \u2014 most database libraries return rows as tuples. So tuple = row is a common mental model. But it's not built into tuples themselves.</li> <li>NumPy arrays \u2014 in NumPy, a 1D array or tuple can be a row vector or column vector depending on context. The shape matters there.</li> <li>CSV reading \u2014 <code>csv.reader</code> returns rows as lists, not tuples. But converting to tuples is common for immutability.</li> </ul>"},{"location":"python-tuples/is-a-tuple-a-row-or-column/#see-also","title":"See also","text":"<ul> <li>What is an example of a tuple?</li> <li>What are the practical uses of tuples in Python?</li> <li>External: https://docs.python.org/3/library/csv.html</li> </ul>"},{"location":"python-tuples/is-a-tuple-an-object-or-string/","title":"Is a tuple an object or a string?","text":"<p>In short</p> <p>A tuple is an object\u2014specifically, an instance of the <code>tuple</code> class. Everything in Python is an object: numbers, strings, functions, even classes themselves. Strings are also objects, but they're instances of the <code>str</code> class. So a tuple isn't a string, it's a different type of object. When you write <code>(1, 2, 3)</code>, Python creates a tuple object in memory with type <code>&lt;class 'tuple'&gt;</code>. The confusion might come from seeing tuples printed as strings, but that's just the string representation of the tuple object. Objects and strings are not mutually exclusive\u2014strings ARE objects too.</p> <p>A tuple is an object. More precisely, it's an instance of Python's built-in <code>tuple</code> class.</p> <p>Everything in Python is an object, including strings. So the question creates a false dichotomy\u2014strings are objects too.</p> <p>Here's how to check what something is:</p> <pre><code>my_tuple = (1, 2, 3)\nmy_string = \"hello\"\n\n# Check types\nprint(type(my_tuple))  # &lt;class 'tuple'&gt;\nprint(type(my_string))  # &lt;class 'str'&gt;\n\n# Both are objects\nprint(isinstance(my_tuple, object))  # True\nprint(isinstance(my_string, object))  # True\n\n# But they're different types\nprint(isinstance(my_tuple, tuple))  # True\nprint(isinstance(my_tuple, str))  # False\n\n# String representation of a tuple\ntuple_as_string = str(my_tuple)\nprint(tuple_as_string)  # \"(1, 2, 3)\"\nprint(type(tuple_as_string))  # &lt;class 'str'&gt;\n</code></pre> <p>Both show <code>True</code> for <code>isinstance(..., object)</code> because everything inherits from <code>object</code>. But they're different specific types: <code>tuple</code> vs <code>str</code>.</p> <p>When you print a tuple, Python converts it to a string representation. But the tuple itself isn't a string.</p>"},{"location":"python-tuples/is-a-tuple-an-object-or-string/#gotchas","title":"Gotchas","text":"<ul> <li>Everything is an object \u2014 in Python, literally everything is an object. Numbers, booleans, functions, modules, classes. Object-oriented all the way down.</li> <li>String representation \u2014 <code>str(my_tuple)</code> converts a tuple to its string form. But that's not the same as the tuple being a string.</li> <li>Type vs instance \u2014 <code>tuple</code> is a type (class). <code>(1, 2, 3)</code> is an instance (object) of that type.</li> </ul>"},{"location":"python-tuples/is-a-tuple-an-object-or-string/#see-also","title":"See also","text":"<ul> <li>What is a tuple in Python?</li> <li>What is called a tuple in Python?</li> <li>External: https://docs.python.org/3/reference/datamodel.html#objects-values-and-types</li> </ul>"},{"location":"python-tuples/is-a-tuple-just-an-array/","title":"Is a tuple just an array?","text":"<p>In short</p> <p>No. Tuples and arrays are fundamentally different. Tuples are Python's built-in immutable sequences\u2014you can't change them after creation. Arrays (NumPy) are mutable, enforce uniform types, and are optimized for numerical computation with vectorized operations. Tuples accept mixed types: <code>(1, \"hello\", 3.14)</code>. Arrays typically hold one type for performance. Tuples have no math operations beyond basics. Arrays support matrix math, broadcasting, and scientific computing. Use tuples for general data structures. Use arrays for number crunching.</p> <p>Tuples and arrays serve completely different purposes.</p> <p>A tuple is a general-purpose immutable sequence. An array is a specialized container for numeric operations.</p> <p>In the following example, we compare their characteristics:</p> <pre><code>import numpy as np\n\n# Tuple: immutable, mixed types\nmy_tuple = (1, \"text\", 3.14, [1, 2])\nprint(f\"Tuple: {my_tuple}\")\nprint(f\"Type: {type(my_tuple)}\")\n\n# Can't modify\ntry:\n    my_tuple[0] = 99\nexcept TypeError as e:\n    print(f\"Tuple error: {e}\")\n\n# NumPy array: mutable, single type\nmy_array = np.array([1, 2, 3, 4])\nprint(f\"\\nArray: {my_array}\")\nprint(f\"Type: {type(my_array)}\")\nprint(f\"Dtype: {my_array.dtype}\")\n\n# CAN modify\nmy_array[0] = 99\nprint(f\"Modified: {my_array}\")\n\n# Arrays support vectorized math\nresult = my_array * 2 + 10\nprint(f\"Math: {result}\")\n\n# Tuples repeat when multiplied\ntuple_result = my_tuple * 2\nprint(f\"Tuple * 2: {tuple_result}\")  # Concatenates, doesn't multiply elements\n</code></pre> <p>The tuple is mixed-type and immutable. The array is uniform-type (int64), mutable, and supports element-wise math. Multiplying a tuple repeats it; multiplying an array performs math on each element.</p> <p>Completely different tools for different problems.</p>"},{"location":"python-tuples/is-a-tuple-just-an-array/#gotchas","title":"Gotchas","text":"<ul> <li>Python's array module \u2014 there's also <code>array.array</code> in the standard library, but it's less used than NumPy. Still mutable and typed, but no fancy math operations.</li> <li>Tuples can contain arrays \u2014 <code>t = (np.array([1, 2]), \"data\")</code> is valid. The tuple structure is frozen, but the array inside can be modified.</li> <li>Performance context matters \u2014 for a handful of values, tuple vs array makes no difference. For millions, arrays dominate for numeric work.</li> </ul>"},{"location":"python-tuples/is-a-tuple-just-an-array/#see-also","title":"See also","text":"<ul> <li>What is a tuple vs array in Python?</li> <li>Is a tuple faster than an array?</li> <li>External: https://numpy.org/doc/stable/user/absolute_beginners.html</li> </ul>"},{"location":"python-tuples/is-dict-mutable-in-python/","title":"Is dict mutable in Python?","text":"<p>In short</p> <p>Yes, dictionaries are completely mutable. You can add new keys, delete existing ones, update values, even clear the entire dict. This makes them flexible for dynamic data but means they can't be used as dict keys or set members (not hashable). Dict keys must be immutable (strings, numbers, tuples), but values can be anything, including other dicts or lists. The mutability lets you build complex nested structures and modify them freely. If you need an immutable dict-like structure, check out <code>types.MappingProxyType</code> for read-only dict views.</p> <p>Dictionaries are mutable\u2014you can modify them freely after creation.</p> <p>Just like lists, dicts can grow, shrink, and change.</p> <p>In the following example, we demonstrate dict mutability:</p> <pre><code># Create a dict\nperson = {\"name\": \"Alice\", \"age\": 30}\nprint(person)\n\n# Add new key-value pair\nperson[\"email\"] = \"alice@example.com\"\nprint(person)\n\n# Modify existing value\nperson[\"age\"] = 31\nprint(person)\n\n# Delete a key\ndel person[\"email\"]\nprint(person)\n\n# Update multiple at once\nperson.update({\"city\": \"NYC\", \"age\": 32})\nprint(person)\n\n# Clear everything\nperson.clear()\nprint(person)  # {}\n\n# Dicts can't be dict keys (not hashable)\ntry:\n    nested = {person: \"value\"}\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n\n# But tuples can (if they contain only immutables)\nkey_tuple = (\"name\", \"age\")\nvalid_dict = {key_tuple: \"metadata\"}\nprint(valid_dict)\n</code></pre> <p>The dict accepts all modifications\u2014additions, changes, deletions. But trying to use a dict as a key fails because mutable objects aren't hashable.</p> <p>That mutability is what makes dicts powerful for dynamic data structures.</p>"},{"location":"python-tuples/is-dict-mutable-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Keys must be immutable \u2014 you can't use lists or dicts as keys. Tuples work, but only if they contain immutable items.</li> <li>Dict values can be anything \u2014 mutable or immutable. <code>{\"key\": [1, 2, 3]}</code> is fine.</li> <li>Shared references \u2014 <code>dict2 = dict1</code> creates a reference, not a copy. Modify one, both change. Use <code>dict2 = dict1.copy()</code> for independence.</li> </ul>"},{"location":"python-tuples/is-dict-mutable-in-python/#see-also","title":"See also","text":"<ul> <li>Are tuples immutable?</li> <li>What cannot have duplicates in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#dictionaries</li> </ul>"},{"location":"python-tuples/is-python-list-ordered-or-unordered/","title":"Is Python list ordered or unordered?","text":"<p>In short</p> <p>Lists are ordered. They remember the exact sequence you added items in and maintain that order. <code>[3, 1, 2]</code> stays <code>[3, 1, 2]</code> until you explicitly change it. You can access elements by position: <code>my_list[0]</code> always gives the first element. Tuples are also ordered. Dicts preserve insertion order (Python 3.7+). Sets are the unordered ones\u2014they don't guarantee any particular sequence. If order matters, use lists or tuples. If you just need membership testing and don't care about sequence, use sets.</p> <p>Lists are fully ordered collections.</p> <p>They maintain insertion order and let you access elements by numeric index.</p> <p>In the following example, we see how lists preserve order:</p> <pre><code># Order is maintained\nmy_list = [3, 1, 4, 1, 5]\nprint(my_list)  # [3, 1, 4, 1, 5]\n\n# Add more - order still preserved\nmy_list.append(9)\nprint(my_list)  # [3, 1, 4, 1, 5, 9]\n\n# Access by position\nprint(f\"First: {my_list[0]}\")  # 3\nprint(f\"Last: {my_list[-1]}\")  # 9\n\n# Slicing maintains order\nprint(my_list[1:4])  # [1, 4, 1]\n\n# Compare with set (unordered)\nmy_set = {3, 1, 4, 1, 5}\nprint(my_set)  # {1, 3, 4, 5} - duplicates removed, order may differ\n\n# Can't index into a set\ntry:\n    print(my_set[0])\nexcept TypeError as e:\n    print(f\"Set error: {e}\")\n</code></pre> <p>The list keeps <code>[3, 1, 4, 1, 5, 9]</code> exactly as added. The set removes duplicates and doesn't support indexing.</p> <p>Order is a defining feature of lists and tuples.</p>"},{"location":"python-tuples/is-python-list-ordered-or-unordered/#gotchas","title":"Gotchas","text":"<ul> <li>Sorting changes order \u2014 <code>my_list.sort()</code> rearranges elements. But that's explicit\u2014lists don't reorder on their own.</li> <li>Dicts are ordered now \u2014 Python 3.7+ dicts maintain insertion order too. But that's relatively recent (pre-3.7 dicts were unordered).</li> <li>Sets have no index \u2014 you can't do <code>my_set[0]</code>. Sets are for membership testing, not positional access.</li> </ul>"},{"location":"python-tuples/is-python-list-ordered-or-unordered/#see-also","title":"See also","text":"<ul> <li>Does tuple keep order in Python?</li> <li>What cannot have duplicates in Python?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html</li> </ul>"},{"location":"python-tuples/is-tuple-faster-than-array/","title":"Is a tuple faster than an array?","text":"<p>In short</p> <p>Depends what you're doing. Tuples are faster to create (literal syntax) and iterate for small sequences. But NumPy arrays obliterate tuples for numerical operations\u2014vectorized math, matrix operations, and statistical functions are 10-100x faster on arrays. Arrays store data in contiguous memory and use optimized C code. Tuples are generic Python objects. For coordinates or a few values? Tuple is fine. For thousands of numbers with math operations? Array wins by miles. Don't use tuples for numerical computation. That's what arrays (and NumPy) were built for.</p> <p>Tuples and arrays are optimized for completely different workloads.</p> <p>Tuples: fast creation, general-purpose. Arrays: numerical domination.</p> <p>In the following example, we compare creation and computation:</p> <pre><code>import timeit\nimport numpy as np\n\n# Creation speed (tuples win)\ntuple_create = timeit.timeit(\"(1, 2, 3, 4, 5)\", number=1000000)\narray_create = timeit.timeit(\n    \"np.array([1, 2, 3, 4, 5])\",\n    setup=\"import numpy as np\",\n    number=1000000\n)\n\nprint(f\"Tuple creation: {tuple_create:.4f}s\")\nprint(f\"Array creation: {array_create:.4f}s\")\nprint(f\"Tuples are {array_create/tuple_create:.2f}x faster\\n\")\n\n# Math operations (arrays destroy tuples)\nmy_tuple = tuple(range(10000))\nmy_array = np.array(range(10000))\n\n# Tuple: need explicit loop\ntuple_math = timeit.timeit(\n    \"tuple(x * 2 for x in t)\",\n    setup=\"t = tuple(range(10000))\",\n    number=1000\n)\n\n# Array: vectorized operation\narray_math = timeit.timeit(\n    \"a * 2\",\n    setup=\"import numpy as np; a = np.array(range(10000))\",\n    number=1000\n)\n\nprint(f\"Tuple math: {tuple_math:.4f}s\")\nprint(f\"Array math: {array_math:.4f}s\")\nprint(f\"Arrays are {tuple_math/array_math:.2f}x faster for math\")\n</code></pre> <p>Tuples create faster because <code>(1, 2, 3)</code> is a literal. Arrays need function calls and memory allocation. But for math? Arrays win massively because they're built for it.</p> <p>Choose based on your workload, not generic \"speed.\"</p>"},{"location":"python-tuples/is-tuple-faster-than-array/#gotchas","title":"Gotchas","text":"<ul> <li>Apples and oranges \u2014 comparing tuple vs array is like comparing a screwdriver to a power drill. Different tools, different jobs.</li> <li>Array overhead \u2014 for 5 elements, the array overhead (imports, memory layout) might make tuples faster overall. For 10,000 elements with math, no contest.</li> <li>Memory efficiency \u2014 tuples store pointers to Python objects. Arrays store raw data in typed, contiguous memory. Arrays are way more memory-efficient for numbers.</li> </ul>"},{"location":"python-tuples/is-tuple-faster-than-array/#see-also","title":"See also","text":"<ul> <li>What is a tuple vs array in Python?</li> <li>Is tuple or list faster?</li> <li>External: https://numpy.org/doc/stable/user/whatisnumpy.html</li> </ul>"},{"location":"python-tuples/is-tuple-or-list-faster/","title":"Is tuple or list faster?","text":"<p>In short</p> <p>Tuples are faster to create (~2-3x) and slightly faster to iterate over. Lists are faster for append/remove operations. But honestly? The difference is negligible for most use cases (&lt;1000 elements). Tuples win on creation because Python can optimize immutable objects better\u2014constant folding, reuse, less memory allocation. Lists need extra space for growth. Choose tuples for semantics (immutability) and hashability, not micro-optimization. If you're creating millions of small sequences in a tight loop, tuples are measurably faster. Otherwise, pick what makes your code clearer.</p> <p>Tuples are generally faster, but the reasons matter more than the raw speed.</p> <p>The performance advantage comes from immutability.</p> <p>In the following example, we compare creation and iteration speed:</p> <pre><code>import timeit\n\n# Creation speed\ntuple_time = timeit.timeit(\"(1, 2, 3, 4, 5)\", number=1000000)\nlist_time = timeit.timeit(\"[1, 2, 3, 4, 5]\", number=1000000)\n\nprint(f\"Tuple creation: {tuple_time:.4f}s\")\nprint(f\"List creation: {list_time:.4f}s\")\nprint(f\"Tuples are {list_time/tuple_time:.2f}x faster\\n\")\n\n# Iteration speed (minimal difference)\ntuple_iter = timeit.timeit(\n    \"for x in (1, 2, 3, 4, 5): pass\", \n    number=1000000\n)\nlist_iter = timeit.timeit(\n    \"for x in [1, 2, 3, 4, 5]: pass\",\n    number=1000000\n)\n\nprint(f\"Tuple iteration: {tuple_iter:.4f}s\")\nprint(f\"List iteration: {list_iter:.4f}s\")\n\n# But lists are faster for modifications\nimport sys\nt = (1, 2, 3, 4, 5)\nl = [1, 2, 3, 4, 5]\n\nprint(f\"\\nTuple size: {sys.getsizeof(t)} bytes\")\nprint(f\"List size: {sys.getsizeof(l)} bytes\")\n</code></pre> <p>Tuples create faster (often 2-3x) because Python doesn't need to over-allocate space for growth. Iteration is comparable. Lists use more memory because they reserve space for future appends.</p> <p>But if you're appending constantly, lists win\u2014tuples need to create entirely new tuples each time.</p>"},{"location":"python-tuples/is-tuple-or-list-faster/#gotchas","title":"Gotchas","text":"<ul> <li>Small differences \u2014 for everyday code with &lt;100 elements, you won't notice the speed difference. Don't choose based on this alone.</li> <li>Context matters \u2014 creating tuples in a hot loop (millions of times)? Measurable win. Occasional use? Irrelevant.</li> <li>Lists have methods \u2014 the speed of <code>list.append()</code> vs tuple concatenation <code>t + (new_item,)</code> is huge. Lists win for dynamic operations.</li> </ul>"},{"location":"python-tuples/is-tuple-or-list-faster/#see-also","title":"See also","text":"<ul> <li>What are the advantages of a tuple over a list?</li> <li>Is a tuple faster than an array?</li> <li>External: https://wiki.python.org/moin/TimeComplexity</li> </ul>"},{"location":"python-tuples/main-differences-between-list-and-tuple/","title":"What are the main differences between list and tuple in Python?","text":"<p>In short</p> <p>Four main differences: (1) Mutability - lists can be modified, tuples can't. (2) Syntax - lists use square brackets <code>[]</code>, tuples use parentheses <code>()</code>. (3) Hashability - tuples can be dict keys, lists can't. (4) Performance - tuples are slightly faster and use less memory. (5) Methods - lists have append/remove/etc, tuples have minimal methods. (6) Semantics - lists say \"working collection,\" tuples say \"fixed structure.\" Choose lists for collections you'll modify. Choose tuples for immutable data like coordinates, returns, or config.</p> <p>The differences boil down to mutability and everything that flows from it.</p> <p>Here's a side-by-side comparison:</p> <p>In the following example, we compare all major differences:</p> <pre><code># 1. MUTABILITY\nmy_list = [1, 2, 3]\nmy_list.append(4)  # \u2713 Works\nmy_list[0] = 99    # \u2713 Works\n\nmy_tuple = (1, 2, 3)\n# my_tuple.append(4)   # \u2717 AttributeError\n# my_tuple[0] = 99     # \u2717 TypeError\n\n# 2. SYNTAX\nlist_example = [1, 2, 3]   # Square brackets\ntuple_example = (1, 2, 3)  # Parentheses\n\n# 3. HASHABILITY\ntuple_dict = {(1, 2): \"value\"}  # \u2713 Works\ntry:\n    list_dict = {[1, 2]: \"value\"}  # \u2717 TypeError\nexcept TypeError as e:\n    print(f\"List as key: {e}\")\n\n# 4. PERFORMANCE\nimport sys\nprint(f\"List size: {sys.getsizeof([1, 2, 3])} bytes\")\nprint(f\"Tuple size: {sys.getsizeof((1, 2, 3))} bytes\")\n\n# 5. METHODS\nprint(f\"List methods: {len([m for m in dir(list) if not m.startswith('_')])}\")\nprint(f\"Tuple methods: {len([m for m in dir(tuple) if not m.startswith('_')])}\")\n\n# 6. USE CASES\n# List: dynamic collection\nshopping_cart = [\"apple\", \"banana\"]\nshopping_cart.append(\"orange\")\n\n# Tuple: fixed structure\ncoordinates = (40.7128, -74.0060)  # Won't change\nrgb_color = (255, 0, 0)  # Red, immutable\n\n# 7. CONVERSION (easy both ways)\nconverted_tuple = tuple(my_list)\nconverted_list = list(my_tuple)\n</code></pre> <p>Lists are flexible and mutable. Tuples are fixed and immutable. That single difference affects everything else.</p> <p>Choose based on whether your data should change.</p>"},{"location":"python-tuples/main-differences-between-list-and-tuple/#gotchas","title":"Gotchas","text":"<ul> <li>Both are ordered \u2014 don't confuse immutability with lack of order. Both maintain sequence.</li> <li>Both allow duplicates \u2014 <code>[1, 1, 2]</code> and <code>(1, 1, 2)</code> both work fine. Sets are the ones that don't allow dupes.</li> <li>Performance difference is minor \u2014 for &lt;1000 elements, you won't notice the speed difference. Choose for semantics.</li> </ul>"},{"location":"python-tuples/main-differences-between-list-and-tuple/#see-also","title":"See also","text":"<ul> <li>What is the difference between a tuple and a list?</li> <li>What are the advantages of a tuple over a list?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html</li> </ul>"},{"location":"python-tuples/practical-uses-of-tuples-in-python/","title":"What are the practical uses of tuples in Python?","text":"<p>In short</p> <p>Tuples excel at: (1) returning multiple values from functions cleanly, (2) serving as dict keys for caching/lookup tables, (3) representing database rows or CSV records, (4) storing coordinates and other geometric data, (5) function argument unpacking with <code>*args</code>, (6) protecting configuration data from modification, (7) swap variables in one line: <code>a, b = b, a</code>. The immutability makes them perfect for data that shouldn't change\u2014you can pass tuples around confident they won't be mutated. And the hashability unlocks patterns lists can't handle, like using coordinate pairs as cache keys.</p> <p>Tuples solve real problems in daily Python programming.</p> <p>Here are the most common practical uses:</p> <p>In the following example, we see tuples in action:</p> <pre><code># 1. Multiple return values (most common)\ndef get_stats(numbers):\n    return (min(numbers), max(numbers), sum(numbers)/len(numbers))\n\nmin_val, max_val, avg = get_stats([1, 2, 3, 4, 5])\nprint(f\"Range: {min_val}-{max_val}, Average: {avg}\")\n\n# 2. Dict keys (caching, memoization)\nfibonacci_cache = {}\n\ndef fib(n):\n    if n in fibonacci_cache:\n        return fibonacci_cache[n]\n    if n &lt;= 1:\n        return n\n    result = fib(n-1) + fib(n-2)\n    fibonacci_cache[n] = result\n    return result\n\n# Can use tuples for multi-parameter keys\ndistance_cache = {}\ndistance_cache[(0, 0, 10, 10)] = 14.14  # from (0,0) to (10,10)\n\n# 3. Immutable data structures\nDAYS = (\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\n# Can't accidentally do DAYS.append(\"Funday\")\n\n# 4. Unpacking and swapping\na, b = 1, 2\na, b = b, a  # Elegant swap\nprint(f\"After swap: a={a}, b={b}\")\n\n# 5. Database/CSV rows\nrows = [\n    (1, \"Alice\", \"Engineering\"),\n    (2, \"Bob\", \"Sales\"),\n    (3, \"Carol\", \"Engineering\")\n]\n\nfor emp_id, name, dept in rows:\n    print(f\"{name} (ID: {emp_id}) - {dept}\")\n\n# 6. Function arguments with *args\ndef print_all(*args):  # args is a tuple\n    print(f\"Got {len(args)} arguments: {args}\")\n\nprint_all(1, 2, 3, \"four\")\n</code></pre> <p>Each use leverages immutability, hashability, or clean unpacking syntax.</p> <p>Tuples are workhorses for structured data.</p>"},{"location":"python-tuples/practical-uses-of-tuples-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Returning None \u2014 instead of returning multiple values where some might be None, consider returning a dict or named tuple for clarity.</li> <li>Too many return values \u2014 if you're returning 5+ values, that's a sign you need a class or at least a <code>namedtuple</code>.</li> <li>Tuple performance \u2014 for millions of tiny tuples, the immutability overhead is minimal. Don't avoid tuples for performance without measuring.</li> </ul>"},{"location":"python-tuples/practical-uses-of-tuples-in-python/#see-also","title":"See also","text":"<ul> <li>When should I use a tuple?</li> <li>What is an example of a tuple?</li> <li>External: https://realpython.com/python-return-multiple-values/</li> </ul>"},{"location":"python-tuples/tuple-vs-array-in-python/","title":"What is a tuple vs array in Python?","text":"<p>In short</p> <p>Tuples are Python's built-in immutable sequences. Arrays (usually NumPy arrays) are mutable, typed, and optimized for numerical operations. Tuples accept mixed types <code>(1, \"hello\", 3.14)</code> and can't change. Arrays enforce one type (like all floats) and support vectorized math operations. Use tuples for general-purpose data grouping, multiple returns, dict keys. Use arrays for scientific computing, linear algebra, and when you need serious math performance. Plain Python doesn't have built-in arrays\u2014you need NumPy or the array module for those.</p> <p>Tuples and arrays serve different purposes with different trade-offs.</p> <p>A tuple is a general-purpose immutable sequence. An array (NumPy) is a specialized mutable container for numeric computation.</p> <p>In the following example, we compare tuples and NumPy arrays:</p> <pre><code>import numpy as np\n\n# Tuple: immutable, mixed types\nmy_tuple = (1, 2, 3, 4, 5)\nprint(my_tuple)\nprint(type(my_tuple))  # &lt;class 'tuple'&gt;\n\n# NumPy array: mutable, single type, math-optimized\nmy_array = np.array([1, 2, 3, 4, 5])\nprint(my_array)\nprint(type(my_array))  # &lt;class 'numpy.ndarray'&gt;\n\n# Tuples can't do element-wise math\n# result = my_tuple * 2  # Would give (1, 2, 3, 4, 5, 1, 2, 3, 4, 5)\n\n# Arrays support vectorized operations\nresult = my_array * 2\nprint(result)  # [ 2  4  6  8 10]\n\n# Tuples can't be modified\ntry:\n    my_tuple[0] = 99\nexcept TypeError as e:\n    print(f\"Tuple error: {e}\")\n\n# Arrays can\nmy_array[0] = 99\nprint(my_array)  # [99  2  3  4  5]\n</code></pre> <p>The tuple stays fixed. The array allows modification and supports fast math operations like <code>* 2</code> across all elements.</p> <p>Arrays are all about performance for numerical work. Tuples are about general data structure immutability.</p>"},{"location":"python-tuples/tuple-vs-array-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Plain Python has array module \u2014 Python's <code>array.array</code> exists for typed arrays, but NumPy is way more popular and powerful.</li> <li>Memory layout \u2014 NumPy arrays store data in contiguous memory blocks, making them cache-friendly. Tuples store pointers to objects.</li> <li>Mixed types \u2014 arrays usually enforce one type. Tuples let you mix: <code>(1, \"text\", 3.14)</code>. Different tools for different jobs.</li> </ul>"},{"location":"python-tuples/tuple-vs-array-in-python/#see-also","title":"See also","text":"<ul> <li>Is a tuple just an array?</li> <li>Is a tuple faster than an array?</li> <li>External: https://numpy.org/doc/stable/user/absolute_beginners.html</li> </ul>"},{"location":"python-tuples/what-cannot-have-duplicates-in-python/","title":"What cannot have duplicates in Python?","text":"<p>In short</p> <p>Sets and dictionary keys cannot have duplicates\u2014Python automatically removes them. Add <code>2</code> to a set twice? You'll only see it once. Try to create a dict with duplicate keys? The last value wins. Lists and tuples, on the other hand, happily keep duplicates. That's the trade-off: sets give you automatic uniqueness and O(1) membership testing, but lose order (pre-3.7) and allow only hashable items. Need uniqueness? Use a set. Need to preserve every element including dupes? Use a list or tuple.</p> <p>Sets and dictionary keys enforce uniqueness automatically.</p> <p>If you try to add duplicates, Python silently removes them (sets) or overwrites them (dicts).</p> <p>In the following example, we see how different structures handle duplicates:</p> <pre><code># Sets automatically remove duplicates\nmy_set = {1, 2, 2, 3, 2}\nprint(my_set)  # {1, 2, 3}\n\nmy_set.add(2)  # Try adding 2 again\nprint(my_set)  # {1, 2, 3} - still only one 2\n\n# Dictionary keys can't duplicate\nmy_dict = {'a': 1, 'b': 2, 'a': 3}\nprint(my_dict)  # {'a': 3, 'b': 2} - last 'a' wins\n\n# Lists and tuples CAN have duplicates\nmy_list = [1, 2, 2, 3, 2]\nprint(my_list)  # [1, 2, 2, 3, 2]\n\nmy_tuple = (1, 2, 2, 3, 2)\nprint(my_tuple)  # (1, 2, 2, 3, 2)\n</code></pre> <p>The set collapses to <code>{1, 2, 3}</code>. The dict keeps only the last value for duplicate key <code>'a'</code>. But the list and tuple preserve all the <code>2</code>s.</p> <p>That automatic deduplication makes sets perfect when you need unique values.</p>"},{"location":"python-tuples/what-cannot-have-duplicates-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Insertion order in sets \u2014 modern Python (3.7+) preserves insertion order in dicts but sets still don't guarantee order reliably. Don't depend on set order.</li> <li>Converting to remove dupes \u2014 <code>unique_list = list(set(my_list))</code> is a common pattern to deduplicate, but it loses order. Use <code>dict.fromkeys(my_list)</code> if order matters.</li> <li>Dict values CAN duplicate \u2014 only keys must be unique. Multiple keys can have the same value: <code>{'a': 1, 'b': 1}</code> is fine.</li> </ul>"},{"location":"python-tuples/what-cannot-have-duplicates-in-python/#see-also","title":"See also","text":"<ul> <li>Can tuples have duplicates?</li> <li>What is the difference between a tuple and a list?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#sets</li> </ul>"},{"location":"python-tuples/what-does-tuple-function-do/","title":"What does the tuple() function do?","text":"<p>In short</p> <p><code>tuple()</code> converts any iterable into a tuple. Pass it a list, string, range, set\u2014anything you can loop over\u2014and you get back an immutable tuple with those elements. <code>tuple([1, 2, 3])</code> gives <code>(1, 2, 3)</code>. <code>tuple(\"hello\")</code> gives <code>('h', 'e', 'l', 'l', 'o')</code>. Called with no arguments, <code>tuple()</code> creates an empty tuple. It's how you freeze mutable sequences or convert other iterables when you need immutability, want to use something as a dict key, or need to pass data to code expecting tuples.</p> <p>The <code>tuple()</code> function creates a tuple from any iterable object.</p> <p>It's the constructor for the tuple type, similar to how <code>list()</code> creates lists or <code>str()</code> creates strings.</p> <p>In the following example, we convert different iterables to tuples:</p> <pre><code># From list\nmy_list = [1, 2, 3]\nt1 = tuple(my_list)\nprint(t1)  # (1, 2, 3)\n\n# From string (splits into characters)\nt2 = tuple(\"hello\")\nprint(t2)  # ('h', 'e', 'l', 'l', 'o')\n\n# From range\nt3 = tuple(range(5))\nprint(t3)  # (0, 1, 2, 3, 4)\n\n# From set (loses order guarantees)\nmy_set = {3, 1, 2}\nt4 = tuple(my_set)\nprint(t4)  # Could be (1, 2, 3) or other order\n\n# Empty tuple\nt5 = tuple()\nprint(t5)  # ()\n\n# Already a tuple? Returns a copy\nt6 = tuple((1, 2, 3))\nprint(t6)  # (1, 2, 3)\n</code></pre> <p>Each conversion creates a new tuple. Strings become tuples of characters. Ranges expand to their values. Sets get frozen into tuple form.</p> <p>The function accepts any iterable\u2014if you can loop over it, you can tuple-ify it.</p>"},{"location":"python-tuples/what-does-tuple-function-do/#gotchas","title":"Gotchas","text":"<ul> <li>Strings become character tuples \u2014 <code>tuple(\"hi\")</code> gives <code>('h', 'i')</code>, not <code>(\"hi\",)</code>. If you want a single-string tuple, use <code>(\"hi\",)</code>.</li> <li>Sets lose order \u2014 converting a set to tuple gives you the elements, but order isn't guaranteed (though Python 3.7+ preserves insertion order in practice).</li> <li>Performance \u2014 for huge iterables, <code>tuple()</code> has to walk through every element. It's O(n) in the length of the iterable.</li> </ul>"},{"location":"python-tuples/what-does-tuple-function-do/#see-also","title":"See also","text":"<ul> <li>How do I turn a list into a tuple?</li> <li>Can I convert a tuple to a list in Python?</li> <li>External: https://docs.python.org/3/library/functions.html#func-tuple</li> </ul>"},{"location":"python-tuples/what-is-a-tuple-for-dummies/","title":"What is a tuple for dummies?","text":"<p>In short</p> <p>Think of a tuple as a sealed envelope. You can put things in when you create it, but once it's sealed, nobody can add, remove, or swap what's inside. You can look at what's in there, count the items, even copy the whole envelope\u2014but the contents stay fixed. In Python, you write tuples with parentheses: <code>(1, 2, 3)</code>. Lists use square brackets <code>[1, 2, 3]</code> and you can change them anytime. Tuples? Nope. That permanence is useful when you want to make sure data doesn't accidentally get modified. Perfect for coordinates, database rows, or returning multiple values from a function.</p> <p>A tuple is just a container that holds multiple items in order, but you can't change it after you create it.</p> <p>Imagine a train with cars. You can see what's in each car, you can walk through them in order, but you can't add cars, remove cars, or swap passengers between them. That's a tuple.</p> <p>Here's a simple example to see the difference:</p> <pre><code># List - you CAN change it\nmy_list = [1, 2, 3]\nmy_list.append(4)  # Works fine\nprint(my_list)  # [1, 2, 3, 4]\n\n# Tuple - you CANNOT change it\nmy_tuple = (1, 2, 3)\ntry:\n    my_tuple.append(4)  # This will fail\nexcept AttributeError as e:\n    print(f\"Nope: {e}\")\n</code></pre> <p>The list happily accepts a new item. The tuple doesn't even have an <code>append</code> method\u2014it's not built for changes.</p> <p>That's the whole story: tuples are read-only sequences. Simple as that.</p>"},{"location":"python-tuples/what-is-a-tuple-for-dummies/#gotchas","title":"Gotchas","text":"<ul> <li>Creating single-item tuples \u2014 <code>(5)</code> is just the number 5. Write <code>(5,)</code> with a comma to make it a tuple. Weird but true.</li> <li>Tuples are still sequences \u2014 you can loop through them, access by index <code>my_tuple[0]</code>, slice them <code>my_tuple[1:3]</code>. Just can't modify.</li> <li>Why use them? \u2014 They're faster, safer (no accidental changes), and you can use them as dictionary keys. Lists can't do that.</li> </ul>"},{"location":"python-tuples/what-is-a-tuple-for-dummies/#see-also","title":"See also","text":"<ul> <li>What is a tuple in Python?</li> <li>Are tuples immutable?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/what-is-a-tuple-in-python/","title":"What is a tuple in Python?","text":"<p>In short</p> <p>A tuple is Python's immutable sibling to the list. Same ordered sequence idea, but once you create it, it's locked\u2014no adding, removing, or changing elements. You write them with parentheses: <code>(1, 2, 3)</code> instead of <code>[1, 2, 3]</code>. That immutability is the whole point. Use tuples when you want to protect data from accidental changes, return multiple values from functions, or use sequences as dictionary keys. They're faster and lighter than lists, but the real win is signaling intent: \"this data structure is fixed.\"</p> <p>A tuple is an ordered collection that can't be modified after creation.</p> <p>Think of it as a list that's been sealed shut. You can read from it, loop through it, but you can't change what's inside.</p> <p>In the following example, we create a tuple and try to modify it:</p> <pre><code># Creating a tuple\ncoordinates = (10, 20)\nprint(coordinates)\nprint(type(coordinates))\n\n# Accessing works fine\nprint(f\"X: {coordinates[0]}, Y: {coordinates[1]}\")\n\n# But modification fails\ntry:\n    coordinates[0] = 15\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n</code></pre> <p>Running this code prints <code>(10, 20)</code> and <code>&lt;class 'tuple'&gt;</code>, then shows the error: <code>'tuple' object does not support item assignment</code>. That's immutability at work\u2014tuples refuse changes.</p> <p>The parentheses and immutability are what make tuples distinct from lists.</p>"},{"location":"python-tuples/what-is-a-tuple-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Parentheses are optional \u2014 <code>x = 1, 2, 3</code> creates a tuple too. The comma makes it a tuple, not the parentheses. But use parentheses for clarity.</li> <li>Single-item tuple needs comma \u2014 <code>(5)</code> is just an int. Write <code>(5,)</code> for a one-element tuple. That trailing comma is required.</li> <li>Immutability is shallow \u2014 if your tuple contains a list, that list can still be modified. The tuple's structure is frozen, but mutable objects inside aren't protected.</li> </ul>"},{"location":"python-tuples/what-is-a-tuple-in-python/#see-also","title":"See also","text":"<ul> <li>Are tuples immutable?</li> <li>What is the difference between a tuple and a list?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/what-is-called-a-tuple-in-python/","title":"What is called a tuple in Python?","text":"<p>In short</p> <p>The term \"tuple\" refers to an immutable, ordered sequence in Python. It's called a tuple (rhymes with \"couple\") because it groups multiple values into a single unit. Mathematically, tuples come from set theory\u2014ordered pairs, triples, n-tuples. In Python, a tuple is any comma-separated sequence, usually wrapped in parentheses: <code>(1, 2, 3)</code>. The name tuple is the general term; specific sizes have names too: pair (2 elements), triple (3), quadruple (4). But in Python code, we just say \"tuple\" regardless of size.</p> <p>A tuple is what Python calls its built-in immutable sequence type.</p> <p>The word tuple comes from mathematics, where it means an ordered collection of elements. Python borrowed the name and the concept.</p> <p>Here's what gets called a tuple in Python:</p> <pre><code># All of these are tuples\ncoordinates = (10, 20)  # pair\nrgb_color = (255, 128, 0)  # triple\nempty = ()  # empty tuple\nsingle = (42,)  # single-element tuple\n\n# Even without parentheses, commas make tuples\nalso_tuple = 1, 2, 3\nprint(type(also_tuple))  # &lt;class 'tuple'&gt;\n\n# Not a tuple\njust_int = (42)  # parentheses without comma = just an int\nprint(type(just_int))  # &lt;class 'int'&gt;\n</code></pre> <p>The type shows <code>&lt;class 'tuple'&gt;</code> for all the actual tuples. The last one is just an int because there's no comma.</p> <p>The commas are what create the tuple, not the parentheses. But we use parentheses for clarity.</p>"},{"location":"python-tuples/what-is-called-a-tuple-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Pronunciation \u2014 some say \"TOO-pull,\" others say \"TUP-pull.\" Both are correct. Python doesn't care.</li> <li>Tuple packing \u2014 <code>x = 1, 2, 3</code> is called \"tuple packing\" because you're packing values into a tuple.</li> <li>Tuple unpacking \u2014 <code>a, b, c = x</code> is \"unpacking\" because you're extracting values from a tuple. Useful terminology to know.</li> </ul>"},{"location":"python-tuples/what-is-called-a-tuple-in-python/#see-also","title":"See also","text":"<ul> <li>What is a tuple in Python?</li> <li>How do you write a tuple in Python?</li> <li>External: https://docs.python.org/3/library/stdtypes.html#tuples</li> </ul>"},{"location":"python-tuples/what-is-slicing-in-python/","title":"What is slicing in python","text":"<p>title: \"What is slicing in Python?\" description: \"Slicing extracts portions using [start:stop:step]. Works on tuples, lists, strings. Returns a new sequence.\" meta:   - name: robots     content: index: follow   - name: keywords     content: Subhajit Bhar, freelance data scientist, OCR, NLP, LLM, RAG, knowledge base, python, tuple, indexing   - name: Publisher     content: Subhajit Bhar date: 2025-10-07 updated: \"2025-10-07\"</p>"},{"location":"python-tuples/what-is-slicing-in-python/#what-is-slicing-in-python","title":"What is slicing in Python?","text":"<p>In short</p> <p>Slicing extracts a portion of a sequence using bracket notation: <code>my_tuple[start:stop:step]</code>. <code>start</code> is inclusive, <code>stop</code> is exclusive. <code>my_tuple[1:4]</code> gives elements at indices 1, 2, 3 (not 4). Omit values to use defaults: <code>[:3]</code> means \"from beginning to index 3\", <code>[2:]</code> means \"from index 2 to end\", <code>[::2]</code> means \"every second element\". Works on tuples, lists, and strings. Always returns a new sequence\u2014the original is unchanged. Negative indices work too: <code>[-3:]</code> gives last 3 elements. Slicing is how you extract subsets without loops.</p> <p>Slicing uses <code>[start:stop:step]</code> syntax to extract portions of sequences.</p> <p>It's one of Python's most useful features for working with ordered data.</p> <p>In the following example, we see slicing in action:</p> <pre><code>my_tuple = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n# Basic slice [start:stop]\nprint(my_tuple[2:5])  # (2, 3, 4) - indices 2, 3, 4\n\n# From beginning\nprint(my_tuple[:4])  # (0, 1, 2, 3)\n\n# To end\nprint(my_tuple[6:])  # (6, 7, 8, 9)\n\n# With step [start:stop:step]\nprint(my_tuple[1:8:2])  # (1, 3, 5, 7) - every 2nd element\n\n# Every second element\nprint(my_tuple[::2])  # (0, 2, 4, 6, 8)\n\n# Reverse\nprint(my_tuple[::-1])  # (9, 8, 7, 6, 5, 4, 3, 2, 1, 0)\n\n# Negative indices (last 3)\nprint(my_tuple[-3:])  # (7, 8, 9)\n\n# Copy entire tuple\ncopy = my_tuple[:]\nprint(copy == my_tuple)  # True\nprint(copy is my_tuple)  # True for tuples (immutable)\n</code></pre> <p>Each slice creates a new tuple (or for tuples, sometimes returns the same immutable object). The syntax <code>[start:stop:step]</code> is flexible\u2014omit any part for defaults.</p> <p>Slicing never modifies the original\u2014it always returns a new sequence.</p>"},{"location":"python-tuples/what-is-slicing-in-python/#gotchas","title":"Gotchas","text":"<ul> <li>Stop is exclusive \u2014 <code>my_tuple[0:3]</code> gives indices 0, 1, 2. Not 3. This trips people up constantly.</li> <li>Out of range is fine \u2014 <code>my_tuple[5:100]</code> just gives from index 5 to the end. No error. Python handles it gracefully.</li> <li>Step can't be zero \u2014 <code>my_tuple[::0]</code> raises <code>ValueError</code>. Step must be non-zero.</li> </ul>"},{"location":"python-tuples/what-is-slicing-in-python/#see-also","title":"See also","text":"<ul> <li>How do you access elements in a Python list?</li> <li>What is [-1] in a Python list?</li> <li>External: https://docs.python.org/3/tutorial/introduction.html#lists</li> </ul>"},{"location":"python-tuples/what-is-the-tuple-for-5/","title":"What is the tuple for 5?","text":"<p>In short</p> <p>The tuple for 5 is <code>(5,)</code> with a trailing comma. Without the comma, <code>(5)</code> is just the integer 5 in parentheses\u2014Python sees it as grouping, not a tuple. That trailing comma tells Python \"this is a one-element tuple, not just a number.\" Weird syntax, but it prevents ambiguity. Once you have two or more elements, the comma between them is enough: <code>(5, 6)</code> works fine. But single-element tuples need that explicit comma. It's a quirk everyone learns once and remembers forever.</p> <p>To create a single-element tuple containing 5, you write <code>(5,)</code>.</p> <p>The trailing comma is mandatory. Without it, Python interprets <code>(5)</code> as just the number 5.</p> <p>Here's the difference in action:</p> <pre><code># Not a tuple - just an int in parentheses\nnot_tuple = (5)\nprint(type(not_tuple))  # &lt;class 'int'&gt;\nprint(not_tuple)  # 5\n\n# This IS a tuple\nactual_tuple = (5,)\nprint(type(actual_tuple))  # &lt;class 'tuple'&gt;\nprint(actual_tuple)  # (5,)\nprint(len(actual_tuple))  # 1\n\n# You can also omit parentheses\nalso_tuple = 5,\nprint(type(also_tuple))  # &lt;class 'tuple'&gt;\n</code></pre> <p>The first one is just <code>5</code>. The second is <code>(5,)</code> with length 1. The comma makes all the difference.</p> <p>That trailing comma looks odd, but it's the only way Python can distinguish between a tuple and a parenthesized expression.</p>"},{"location":"python-tuples/what-is-the-tuple-for-5/#gotchas","title":"Gotchas","text":"<ul> <li>Common mistake \u2014 writing <code>(x)</code> when you mean <code>(x,)</code>. This bites everyone at least once. The code runs, but you get an int/string/whatever instead of a tuple.</li> <li>Tuple unpacking fails \u2014 if you try to unpack <code>(5)</code> like <code>a, = (5)</code>, you'll get an error. It only works if it's actually a tuple: <code>a, = (5,)</code>.</li> <li>Parentheses are optional \u2014 <code>5,</code> is valid and creates a tuple. But <code>(5,)</code> is clearer and more conventional.</li> </ul>"},{"location":"python-tuples/what-is-the-tuple-for-5/#see-also","title":"See also","text":"<ul> <li>How do you write a tuple in Python?</li> <li>Can I make an empty tuple?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/when-should-i-use-a-tuple/","title":"When should I use a tuple?","text":"<p>In short</p> <p>Use tuples when: (1) the number of elements is fixed\u2014coordinates, RGB values, date components, (2) you're returning multiple values from a function, (3) you need hashability for dict keys or set members, (4) you want immutability protection\u2014config values, constants, or data passed between functions that shouldn't change. The decision is simple: if the structure is fixed and shouldn't grow/shrink, tuple. If it's a collection you'll modify, list. Tuples signal \"this is a structure\" while lists signal \"this is a working collection.\"</p> <p>Choose tuples when your data has a fixed structure.</p> <p>Here are the clear use cases:</p> <p>In the following example, we see situations where tuples are the right choice:</p> <pre><code># 1. Coordinates and geometric data\npoint_2d = (10, 20)\npoint_3d = (10, 20, 30)\nbounding_box = (0, 0, 100, 100)  # x, y, width, height\n\n# 2. Function returns\ndef calculate_stats(numbers):\n    return (min(numbers), max(numbers), sum(numbers) / len(numbers))\n\nmin_val, max_val, avg = calculate_stats([1, 2, 3, 4, 5])\n\n# 3. Dict keys (can't use lists!)\nlocations = {}\nlocations[(40.7128, -74.0060)] = \"New York\"\nlocations[(51.5074, -0.1278)] = \"London\"\nprint(locations[(40.7128, -74.0060)])\n\n# 4. Constants and configuration\nDATABASE_CONFIG = (\"localhost\", 5432, \"myapp\")\nRGB_RED = (255, 0, 0)\nDAYS_OF_WEEK = (\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\n\n# Can't accidentally modify\n# DAYS_OF_WEEK.append(\"Funday\")  # AttributeError!\n\n# 5. Data integrity\ndef process_transaction(transaction):\n    # transaction is a tuple - caller can't mess with it\n    tx_id, amount, timestamp = transaction\n    print(f\"Processing transaction {tx_id}: ${amount}\")\n\n# Don't use tuple when you need to modify\n# bad_list = (1, 2, 3)\n# bad_list.append(4)  # Can't do this!\n\n# Use list instead\ngood_list = [1, 2, 3]\ngood_list.append(4)  # This works\n</code></pre> <p>Each example shows fixed-structure data that benefits from immutability.</p> <p>When in doubt: if it's a record or structure, use tuple. If it's a collection, use list.</p>"},{"location":"python-tuples/when-should-i-use-a-tuple/#gotchas","title":"Gotchas","text":"<ul> <li>Don't overthink it \u2014 tuples vs lists isn't a make-or-break decision. If you're not sure, start with a list. You can always convert.</li> <li>Named tuples help \u2014 for complex structures, <code>collections.namedtuple</code> gives field names: <code>Point(x=10, y=20)</code> instead of <code>(10, 20)</code>.</li> <li>Tuples can contain mutables \u2014 <code>t = ([1, 2], 3)</code> lets you modify the inner list. Immutability is shallow.</li> </ul>"},{"location":"python-tuples/when-should-i-use-a-tuple/#see-also","title":"See also","text":"<ul> <li>Why might you choose to use a tuple instead of a list in Python?</li> <li>What are the practical uses of tuples in Python?</li> <li>External: https://docs.python.org/3/library/collections.html#collections.namedtuple</li> </ul>"},{"location":"python-tuples/which-of-the-following-is-a-python-tuple/","title":"Which of the following is a Python tuple (4 5 6 4 5 6 4 5 6 {})?","text":"<p>In short</p> <p>From those options, only expressions with parentheses and commas are tuples: <code>(4, 5, 6)</code> is a tuple. <code>4 5 6</code> is a syntax error. <code>{}</code> is an empty dict, not a tuple. To identify tuples: look for comma-separated values, usually in parentheses. <code>(1, 2)</code>, <code>(x,)</code>, or even just <code>1, 2</code> (without parens) are tuples. Square brackets <code>[4, 5, 6]</code> make a list. Curly braces with colons <code>{key: value}</code> make a dict. Curly braces with just values <code>{1, 2}</code> make a set. Parentheses with commas? That's your tuple.</p> <p>Let's clarify tuple syntax by testing different forms:</p> <pre><code># Valid tuple\ntuple1 = (4, 5, 6)\nprint(type(tuple1))  # &lt;class 'tuple'&gt;\nprint(tuple1)  # (4, 5, 6)\n\n# Tuple without parentheses (valid!)\ntuple2 = 4, 5, 6\nprint(type(tuple2))  # &lt;class 'tuple'&gt;\n\n# NOT a tuple - syntax error\ntry:\n    invalid = 4 5 6\nexcept SyntaxError:\n    print(\"4 5 6 is invalid syntax\")\n\n# Empty braces = dict, not tuple\nempty_dict = {}\nprint(type(empty_dict))  # &lt;class 'dict'&gt;\n\n# Empty tuple needs parentheses\nempty_tuple = ()\nprint(type(empty_tuple))  # &lt;class 'tuple'&gt;\n\n# List (square brackets)\nmy_list = [4, 5, 6]\nprint(type(my_list))  # &lt;class 'list'&gt;\n\n# Set (curly braces, no colons)\nmy_set = {4, 5, 6}\nprint(type(my_set))  # &lt;class 'set'&gt;\n</code></pre> <p>Only the first two are tuples. <code>4 5 6</code> without commas or structure is invalid Python. <code>{}</code> creates an empty dict. <code>()</code> creates an empty tuple.</p> <p>The comma is what makes a tuple\u2014parentheses just make it clearer.</p>"},{"location":"python-tuples/which-of-the-following-is-a-python-tuple/#gotchas","title":"Gotchas","text":"<ul> <li>Empty structures \u2014 <code>()</code> is an empty tuple, <code>[]</code> is an empty list, <code>{}</code> is an empty dict (not set!). To make an empty set, use <code>set()</code>.</li> <li>Single-element confusion \u2014 <code>(4)</code> is just <code>4</code>. Write <code>(4,)</code> for a single-element tuple.</li> <li>Commas matter more than parentheses \u2014 <code>x = 1, 2</code> creates a tuple. Parentheses are for grouping and clarity, not requirement (except empty tuples).</li> </ul>"},{"location":"python-tuples/which-of-the-following-is-a-python-tuple/#see-also","title":"See also","text":"<ul> <li>How do you write a tuple in Python?</li> <li>Does a tuple use brackets?</li> <li>External: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences</li> </ul>"},{"location":"python-tuples/why-use-tuple-instead-of-list/","title":"Why might you choose to use a tuple instead of a list in Python?","text":"<p>In short</p> <p>Choose tuples when the data structure is fixed: coordinates <code>(x, y)</code>, RGB colors <code>(255, 0, 0)</code>, database records, configuration values, or function returns with multiple values. Tuples protect against accidental modification\u2014you can't accidentally append to a coordinate or mutate a return value. They work as dict keys, so you can do <code>cache[(x, y)] = result</code>. And they signal intent to other developers: \"this is a structure, not a collection.\" Lists are for dynamic collections you'll modify. Tuples are for fixed data you'll pass around.</p> <p>Use tuples when you want immutability, either for safety or for technical requirements.</p> <p>Here are the main scenarios where tuples shine:</p> <p>In the following example, we see practical tuple use cases:</p> <pre><code># 1. Function returns (common pattern)\ndef get_user():\n    return (\"Alice\", 30, \"alice@example.com\")\n\nname, age, email = get_user()  # Clean unpacking\nprint(f\"{name}, {age}\")\n\n# 2. Dict keys (tuples only)\n# Cache function results by coordinates\ncache = {}\ncache[(10, 20)] = \"expensive calculation result\"\ncache[(15, 25)] = \"another result\"\nprint(cache[(10, 20)])\n\n# 3. Fixed structures (semantic clarity)\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nBLUE = (0, 0, 255)\n\ndef apply_color(color):\n    # Function knows color won't mutate\n    r, g, b = color\n    return f\"rgb({r}, {g}, {b})\"\n\nprint(apply_color(RED))\n\n# 4. Configuration (protect from accidental changes)\nDB_CONFIG = (\"localhost\", 5432, \"mydb\")\nhost, port, dbname = DB_CONFIG\n\n# Can't accidentally do DB_CONFIG.append(\"extra\")\n</code></pre> <p>Each use case leverages immutability: returns don't get modified, cache keys don't change, colors stay constant, config is protected.</p> <p>When structure is fixed, tuple is the natural choice.</p>"},{"location":"python-tuples/why-use-tuple-instead-of-list/#gotchas","title":"Gotchas","text":"<ul> <li>Don't overthink it \u2014 if you're not sure, start with a list. You can always convert later. Premature optimization toward tuples is rarely needed.</li> <li>Tuple unpacking is powerful \u2014 <code>x, y = (10, 20)</code> is cleaner than <code>coords = (10, 20); x = coords[0]; y = coords[1]</code>. Use it.</li> <li>Named tuples exist \u2014 for complex structures, consider <code>collections.namedtuple</code> which gives field names: <code>Point(x=10, y=20)</code>.</li> </ul>"},{"location":"python-tuples/why-use-tuple-instead-of-list/#see-also","title":"See also","text":"<ul> <li>When should I use a tuple?</li> <li>What are the practical uses of tuples in Python?</li> <li>External: https://docs.python.org/3/library/collections.html#collections.namedtuple</li> </ul>"}]}